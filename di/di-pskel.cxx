// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "di-pskel.hxx"

// param_class_type_pskel
//

param_class_type_pskel::
param_class_type_pskel (::xml_schema::string_pskel* tiein)
: ::xml_schema::string_pskel (tiein, 0),
  param_class_type_impl_ (0)
{
  this->_enumeration_facet (_xsde_param_class_type_pskel_enums_, 8UL);
}

param_class_type_pskel::
param_class_type_pskel (param_class_type_pskel* impl, void*)
: ::xml_schema::string_pskel (impl, 0),
  param_class_type_impl_ (impl)
{
  this->_enumeration_facet (_xsde_param_class_type_pskel_enums_, 8UL);
}

// insert_pskel
//

void insert_pskel::
value_parser (::xml_schema::string_pskel& p)
{
  this->value_parser_ = &p;
}

void insert_pskel::
parsers (::xml_schema::string_pskel& value)
{
  this->value_parser_ = &value;
}

insert_pskel::
insert_pskel ()
: insert_impl_ (0),
  value_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

insert_pskel::
insert_pskel (insert_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  insert_impl_ (impl),
  value_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// attribute_type_pskel
//

void attribute_type_pskel::
name_parser (::xml_schema::token_pskel& p)
{
  this->name_parser_ = &p;
}

void attribute_type_pskel::
value_parser (::xml_schema::string_pskel& p)
{
  this->value_parser_ = &p;
}

void attribute_type_pskel::
insert_parser (::insert_pskel& p)
{
  this->insert_parser_ = &p;
}

void attribute_type_pskel::
parsers (::xml_schema::token_pskel& name,
         ::xml_schema::string_pskel& value,
         ::insert_pskel& insert)
{
  this->name_parser_ = &name;
  this->value_parser_ = &value;
  this->insert_parser_ = &insert;
}

attribute_type_pskel::
attribute_type_pskel ()
: attribute_type_impl_ (0),
  name_parser_ (0),
  value_parser_ (0),
  insert_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

attribute_type_pskel::
attribute_type_pskel (attribute_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  attribute_type_impl_ (impl),
  name_parser_ (0),
  value_parser_ (0),
  insert_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// param_type_pskel
//

void param_type_pskel::
type_parser (::param_class_type_pskel& p)
{
  this->type_parser_ = &p;
}

void param_type_pskel::
value_parser (::xml_schema::string_pskel& p)
{
  this->value_parser_ = &p;
}

void param_type_pskel::
parsers (::param_class_type_pskel& type,
         ::xml_schema::string_pskel& value)
{
  this->type_parser_ = &type;
  this->value_parser_ = &value;
}

param_type_pskel::
param_type_pskel ()
: param_type_impl_ (0),
  type_parser_ (0),
  value_parser_ (0)
{
}

param_type_pskel::
param_type_pskel (param_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  param_type_impl_ (impl),
  type_parser_ (0),
  value_parser_ (0)
{
}

// inject_one_type_pskel
//

void inject_one_type_pskel::
injection_parser (::xml_schema::token_pskel& p)
{
  this->injection_parser_ = &p;
}

void inject_one_type_pskel::
slot_parser (::xml_schema::token_pskel& p)
{
  this->slot_parser_ = &p;
}

void inject_one_type_pskel::
parsers (::xml_schema::token_pskel& injection,
         ::xml_schema::token_pskel& slot)
{
  this->injection_parser_ = &injection;
  this->slot_parser_ = &slot;
}

inject_one_type_pskel::
inject_one_type_pskel ()
: inject_one_type_impl_ (0),
  injection_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_one_type_pskel::
inject_one_type_pskel (inject_one_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_one_type_impl_ (impl),
  injection_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// inject_all_type_pskel
//

void inject_all_type_pskel::
receiver_parser (::xml_schema::token_pskel& p)
{
  this->receiver_parser_ = &p;
}

void inject_all_type_pskel::
slot_parser (::xml_schema::token_pskel& p)
{
  this->slot_parser_ = &p;
}

void inject_all_type_pskel::
parsers (::xml_schema::token_pskel& receiver,
         ::xml_schema::token_pskel& slot)
{
  this->receiver_parser_ = &receiver;
  this->slot_parser_ = &slot;
}

inject_all_type_pskel::
inject_all_type_pskel ()
: inject_all_type_impl_ (0),
  receiver_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_all_type_pskel::
inject_all_type_pskel (inject_all_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_all_type_impl_ (impl),
  receiver_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// component_pskel
//

void component_pskel::
name_parser (::xml_schema::token_pskel& p)
{
  this->name_parser_ = &p;
}

void component_pskel::
class__parser (::xml_schema::token_pskel& p)
{
  this->class__parser_ = &p;
}

void component_pskel::
attribute_parser (::attribute_type_pskel& p)
{
  this->attribute_parser_ = &p;
}

void component_pskel::
parsers (::xml_schema::token_pskel& name,
         ::xml_schema::token_pskel& class_,
         ::attribute_type_pskel& attribute)
{
  this->name_parser_ = &name;
  this->class__parser_ = &class_;
  this->attribute_parser_ = &attribute;
}

component_pskel::
component_pskel ()
: component_impl_ (0),
  name_parser_ (0),
  class__parser_ (0),
  attribute_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

component_pskel::
component_pskel (component_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  component_impl_ (impl),
  name_parser_ (0),
  class__parser_ (0),
  attribute_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// inject_pskel
//

void inject_pskel::
receiver_parser (::xml_schema::token_pskel& p)
{
  this->receiver_parser_ = &p;
}

void inject_pskel::
injection_parser (::xml_schema::token_pskel& p)
{
  this->injection_parser_ = &p;
}

void inject_pskel::
slot_parser (::xml_schema::token_pskel& p)
{
  this->slot_parser_ = &p;
}

void inject_pskel::
parsers (::xml_schema::token_pskel& receiver,
         ::xml_schema::token_pskel& injection,
         ::xml_schema::token_pskel& slot)
{
  this->receiver_parser_ = &receiver;
  this->injection_parser_ = &injection;
  this->slot_parser_ = &slot;
}

inject_pskel::
inject_pskel ()
: inject_impl_ (0),
  receiver_parser_ (0),
  injection_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_pskel::
inject_pskel (inject_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_impl_ (impl),
  receiver_parser_ (0),
  injection_parser_ (0),
  slot_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// inject_one_pskel
//

void inject_one_pskel::
receiver_parser (::xml_schema::token_pskel& p)
{
  this->receiver_parser_ = &p;
}

void inject_one_pskel::
inject_parser (::inject_one_type_pskel& p)
{
  this->inject_parser_ = &p;
}

void inject_one_pskel::
parsers (::xml_schema::token_pskel& receiver,
         ::inject_one_type_pskel& inject)
{
  this->receiver_parser_ = &receiver;
  this->inject_parser_ = &inject;
}

inject_one_pskel::
inject_one_pskel ()
: inject_one_impl_ (0),
  receiver_parser_ (0),
  inject_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_one_pskel::
inject_one_pskel (inject_one_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_one_impl_ (impl),
  receiver_parser_ (0),
  inject_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// inject_all_pskel
//

void inject_all_pskel::
injection_parser (::xml_schema::token_pskel& p)
{
  this->injection_parser_ = &p;
}

void inject_all_pskel::
inject_parser (::inject_all_type_pskel& p)
{
  this->inject_parser_ = &p;
}

void inject_all_pskel::
parsers (::xml_schema::token_pskel& injection,
         ::inject_all_type_pskel& inject)
{
  this->injection_parser_ = &injection;
  this->inject_parser_ = &inject;
}

inject_all_pskel::
inject_all_pskel ()
: inject_all_impl_ (0),
  injection_parser_ (0),
  inject_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_all_pskel::
inject_all_pskel (inject_all_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_all_impl_ (impl),
  injection_parser_ (0),
  inject_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// inject_slot_pskel
//

void inject_slot_pskel::
slot_parser (::xml_schema::token_pskel& p)
{
  this->slot_parser_ = &p;
}

void inject_slot_pskel::
injection_parser (::xml_schema::token_pskel& p)
{
  this->injection_parser_ = &p;
}

void inject_slot_pskel::
parsers (::xml_schema::token_pskel& slot,
         ::xml_schema::token_pskel& injection)
{
  this->slot_parser_ = &slot;
  this->injection_parser_ = &injection;
}

inject_slot_pskel::
inject_slot_pskel ()
: inject_slot_impl_ (0),
  slot_parser_ (0),
  injection_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

inject_slot_pskel::
inject_slot_pskel (inject_slot_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  inject_slot_impl_ (impl),
  slot_parser_ (0),
  injection_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// DI_pskel
//

void DI_pskel::
plugins_parser (::plugins_pskel& p)
{
  this->plugins_parser_ = &p;
}

void DI_pskel::
components_parser (::components_pskel& p)
{
  this->components_parser_ = &p;
}

void DI_pskel::
wiring_parser (::wiring_pskel& p)
{
  this->wiring_parser_ = &p;
}

void DI_pskel::
parsers (::plugins_pskel& plugins,
         ::components_pskel& components,
         ::wiring_pskel& wiring)
{
  this->plugins_parser_ = &plugins;
  this->components_parser_ = &components;
  this->wiring_parser_ = &wiring;
}

DI_pskel::
DI_pskel ()
: DI_impl_ (0),
  plugins_parser_ (0),
  components_parser_ (0),
  wiring_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

DI_pskel::
DI_pskel (DI_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  DI_impl_ (impl),
  plugins_parser_ (0),
  components_parser_ (0),
  wiring_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// shared_pskel
//

void shared_pskel::
lib_parser (::xml_schema::name_pskel& p)
{
  this->lib_parser_ = &p;
}

void shared_pskel::
parsers (::xml_schema::name_pskel& lib)
{
  this->lib_parser_ = &lib;
}

shared_pskel::
shared_pskel ()
: shared_impl_ (0),
  lib_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

shared_pskel::
shared_pskel (shared_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  shared_impl_ (impl),
  lib_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// plugins_pskel
//

void plugins_pskel::
shared_parser (::shared_pskel& p)
{
  this->shared_parser_ = &p;
}

void plugins_pskel::
parsers (::shared_pskel& shared)
{
  this->shared_parser_ = &shared;
}

plugins_pskel::
plugins_pskel ()
: plugins_impl_ (0),
  shared_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

plugins_pskel::
plugins_pskel (plugins_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  plugins_impl_ (impl),
  shared_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// components_pskel
//

void components_pskel::
component_parser (::component_pskel& p)
{
  this->component_parser_ = &p;
}

void components_pskel::
parsers (::component_pskel& component)
{
  this->component_parser_ = &component;
}

components_pskel::
components_pskel ()
: components_impl_ (0),
  component_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

components_pskel::
components_pskel (components_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  components_impl_ (impl),
  component_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// wiring_pskel
//

void wiring_pskel::
inject_parser (::inject_pskel& p)
{
  this->inject_parser_ = &p;
}

void wiring_pskel::
inject_all_parser (::inject_all_pskel& p)
{
  this->inject_all_parser_ = &p;
}

void wiring_pskel::
inject_one_parser (::inject_one_pskel& p)
{
  this->inject_one_parser_ = &p;
}

void wiring_pskel::
inject_slot_parser (::inject_slot_pskel& p)
{
  this->inject_slot_parser_ = &p;
}

void wiring_pskel::
parsers (::inject_pskel& inject,
         ::inject_all_pskel& inject_all,
         ::inject_one_pskel& inject_one,
         ::inject_slot_pskel& inject_slot)
{
  this->inject_parser_ = &inject;
  this->inject_all_parser_ = &inject_all;
  this->inject_one_parser_ = &inject_one;
  this->inject_slot_parser_ = &inject_slot;
}

wiring_pskel::
wiring_pskel ()
: wiring_impl_ (0),
  inject_parser_ (0),
  inject_all_parser_ (0),
  inject_one_parser_ (0),
  inject_slot_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

wiring_pskel::
wiring_pskel (wiring_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  wiring_impl_ (impl),
  inject_parser_ (0),
  inject_all_parser_ (0),
  inject_one_parser_ (0),
  inject_slot_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

#include <assert.h>

// param_class_type_pskel
//

::std::string param_class_type_pskel::
post_string ()
{
  assert (this->string_impl_);
  return this->string_impl_->post_string ();
}

const char* const param_class_type_pskel::_xsde_param_class_type_pskel_enums_[8UL] = 
{
  "bool",
  "char",
  "double",
  "int",
  "long",
  "string",
  "unsigned char",
  "unsigned int"
};

// insert_pskel
//

void insert_pskel::
value (const ::std::string& x)
{
  if (this->insert_impl_)
    this->insert_impl_->value (x);
}

void insert_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->value_parser_)
    this->value_parser_->_reset ();
}

// attribute_type_pskel
//

void attribute_type_pskel::
name (const ::std::string& x)
{
  if (this->attribute_type_impl_)
    this->attribute_type_impl_->name (x);
}

void attribute_type_pskel::
value (const ::std::string& x)
{
  if (this->attribute_type_impl_)
    this->attribute_type_impl_->value (x);
}

void attribute_type_pskel::
insert (const ::insert& x)
{
  if (this->attribute_type_impl_)
    this->attribute_type_impl_->insert (x);
}

void attribute_type_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->value_parser_)
    this->value_parser_->_reset ();

  this->resetting_ = true;

  if (this->insert_parser_)
    this->insert_parser_->_reset ();

  this->resetting_ = false;
}

// param_type_pskel
//

void param_type_pskel::
type (const ::param_class_type& x)
{
  if (this->param_type_impl_)
    this->param_type_impl_->type (x);
}

void param_type_pskel::
value (const ::std::string& x)
{
  if (this->param_type_impl_)
    this->param_type_impl_->value (x);
}

void param_type_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  if (this->type_parser_)
    this->type_parser_->_reset ();

  if (this->value_parser_)
    this->value_parser_->_reset ();
}

// inject_one_type_pskel
//

void inject_one_type_pskel::
injection (const ::std::string& x)
{
  if (this->inject_one_type_impl_)
    this->inject_one_type_impl_->injection (x);
}

void inject_one_type_pskel::
slot (const ::std::string& x)
{
  if (this->inject_one_type_impl_)
    this->inject_one_type_impl_->slot (x);
}

void inject_one_type_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->injection_parser_)
    this->injection_parser_->_reset ();

  if (this->slot_parser_)
    this->slot_parser_->_reset ();
}

// inject_all_type_pskel
//

void inject_all_type_pskel::
receiver (const ::std::string& x)
{
  if (this->inject_all_type_impl_)
    this->inject_all_type_impl_->receiver (x);
}

void inject_all_type_pskel::
slot (const ::std::string& x)
{
  if (this->inject_all_type_impl_)
    this->inject_all_type_impl_->slot (x);
}

void inject_all_type_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->receiver_parser_)
    this->receiver_parser_->_reset ();

  if (this->slot_parser_)
    this->slot_parser_->_reset ();
}

// component_pskel
//

void component_pskel::
name (const ::std::string& x)
{
  if (this->component_impl_)
    this->component_impl_->name (x);
}

void component_pskel::
class_ (const ::std::string& x)
{
  if (this->component_impl_)
    this->component_impl_->class_ (x);
}

void component_pskel::
attribute (::attribute_type* x)
{
  if (this->component_impl_)
    this->component_impl_->attribute (x);
}

void component_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->class__parser_)
    this->class__parser_->_reset ();

  this->resetting_ = true;

  if (this->attribute_parser_)
    this->attribute_parser_->_reset ();

  this->resetting_ = false;
}

// inject_pskel
//

void inject_pskel::
receiver (const ::std::string& x)
{
  if (this->inject_impl_)
    this->inject_impl_->receiver (x);
}

void inject_pskel::
injection (const ::std::string& x)
{
  if (this->inject_impl_)
    this->inject_impl_->injection (x);
}

void inject_pskel::
slot (const ::std::string& x)
{
  if (this->inject_impl_)
    this->inject_impl_->slot (x);
}

void inject_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->receiver_parser_)
    this->receiver_parser_->_reset ();

  if (this->injection_parser_)
    this->injection_parser_->_reset ();

  if (this->slot_parser_)
    this->slot_parser_->_reset ();
}

// inject_one_pskel
//

void inject_one_pskel::
receiver (const ::std::string& x)
{
  if (this->inject_one_impl_)
    this->inject_one_impl_->receiver (x);
}

void inject_one_pskel::
inject (const ::inject_one_type& x)
{
  if (this->inject_one_impl_)
    this->inject_one_impl_->inject (x);
}

void inject_one_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->receiver_parser_)
    this->receiver_parser_->_reset ();

  this->resetting_ = true;

  if (this->inject_parser_)
    this->inject_parser_->_reset ();

  this->resetting_ = false;
}

// inject_all_pskel
//

void inject_all_pskel::
injection (const ::std::string& x)
{
  if (this->inject_all_impl_)
    this->inject_all_impl_->injection (x);
}

void inject_all_pskel::
inject (const ::inject_all_type& x)
{
  if (this->inject_all_impl_)
    this->inject_all_impl_->inject (x);
}

void inject_all_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->injection_parser_)
    this->injection_parser_->_reset ();

  this->resetting_ = true;

  if (this->inject_parser_)
    this->inject_parser_->_reset ();

  this->resetting_ = false;
}

// inject_slot_pskel
//

void inject_slot_pskel::
slot (const ::std::string& x)
{
  if (this->inject_slot_impl_)
    this->inject_slot_impl_->slot (x);
}

void inject_slot_pskel::
injection (const ::std::string& x)
{
  if (this->inject_slot_impl_)
    this->inject_slot_impl_->injection (x);
}

void inject_slot_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->slot_parser_)
    this->slot_parser_->_reset ();

  if (this->injection_parser_)
    this->injection_parser_->_reset ();
}

// DI_pskel
//

void DI_pskel::
plugins (::plugins* x)
{
  if (this->DI_impl_)
    this->DI_impl_->plugins (x);
}

void DI_pskel::
components (::components* x)
{
  if (this->DI_impl_)
    this->DI_impl_->components (x);
}

void DI_pskel::
wiring (::wiring* x)
{
  if (this->DI_impl_)
    this->DI_impl_->wiring (x);
}

void DI_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->plugins_parser_)
    this->plugins_parser_->_reset ();

  if (this->components_parser_)
    this->components_parser_->_reset ();

  if (this->wiring_parser_)
    this->wiring_parser_->_reset ();

  this->resetting_ = false;
}

// shared_pskel
//

void shared_pskel::
lib (const ::std::string& x)
{
  if (this->shared_impl_)
    this->shared_impl_->lib (x);
}

void shared_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->lib_parser_)
    this->lib_parser_->_reset ();
}

// plugins_pskel
//

void plugins_pskel::
shared (const ::shared& x)
{
  if (this->plugins_impl_)
    this->plugins_impl_->shared (x);
}

void plugins_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->shared_parser_)
    this->shared_parser_->_reset ();

  this->resetting_ = false;
}

// components_pskel
//

void components_pskel::
component (::component* x)
{
  if (this->components_impl_)
    this->components_impl_->component (x);
}

void components_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->component_parser_)
    this->component_parser_->_reset ();

  this->resetting_ = false;
}

// wiring_pskel
//

void wiring_pskel::
inject (const ::inject& x)
{
  if (this->wiring_impl_)
    this->wiring_impl_->inject (x);
}

void wiring_pskel::
inject_all (::inject_all* x)
{
  if (this->wiring_impl_)
    this->wiring_impl_->inject_all (x);
}

void wiring_pskel::
inject_one (::inject_one* x)
{
  if (this->wiring_impl_)
    this->wiring_impl_->inject_one (x);
}

void wiring_pskel::
inject_slot (const ::inject_slot& x)
{
  if (this->wiring_impl_)
    this->wiring_impl_->inject_slot (x);
}

void wiring_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->inject_parser_)
    this->inject_parser_->_reset ();

  if (this->inject_all_parser_)
    this->inject_all_parser_->_reset ();

  if (this->inject_one_parser_)
    this->inject_one_parser_->_reset ();

  if (this->inject_slot_parser_)
    this->inject_slot_parser_->_reset ();

  this->resetting_ = false;
}

#include <assert.h>

// Element validation and dispatch functions for attribute_type_pskel.
//
bool attribute_type_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "insert" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &attribute_type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool attribute_type_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void attribute_type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void attribute_type_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void attribute_type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "insert" && ns.empty ())
      {
        if (start)
        {
          if (this->insert_parser_)
          {
            this->insert_parser_->pre ();
            ctx.nested_parser (this->insert_parser_);
          }
        }
        else
        {
          if (this->insert_parser_ != 0)
          {
            const ::insert& tmp = this->insert_parser_->post_insert ();
            this->insert (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for component_pskel.
//
bool component_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "attribute" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &component_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool component_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void component_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void component_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void component_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "attribute" && ns.empty ())
      {
        if (start)
        {
          if (this->attribute_parser_)
          {
            this->attribute_parser_->pre ();
            ctx.nested_parser (this->attribute_parser_);
          }
        }
        else
        {
          if (this->attribute_parser_ != 0)
          {
            ::attribute_type* tmp = this->attribute_parser_->post_attribute_type ();
            this->attribute (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for inject_one_pskel.
//
bool inject_one_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "inject" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &inject_one_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool inject_one_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void inject_one_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void inject_one_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void inject_one_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "inject" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_parser_)
          {
            this->inject_parser_->pre ();
            ctx.nested_parser (this->inject_parser_);
          }
        }
        else
        {
          if (this->inject_parser_ != 0)
          {
            const ::inject_one_type& tmp = this->inject_parser_->post_inject_one_type ();
            this->inject (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for inject_all_pskel.
//
bool inject_all_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "inject" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &inject_all_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool inject_all_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void inject_all_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void inject_all_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void inject_all_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "inject" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_parser_)
          {
            this->inject_parser_->pre ();
            ctx.nested_parser (this->inject_parser_);
          }
        }
        else
        {
          if (this->inject_parser_ != 0)
          {
            const ::inject_all_type& tmp = this->inject_parser_->post_inject_all_type ();
            this->inject (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for DI_pskel.
//
bool DI_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "plugins" && ns.empty ())
        s = 0UL;
      else if (n == "components" && ns.empty ())
        s = 1UL;
      else if (n == "wiring" && ns.empty ())
        s = 2UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &DI_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool DI_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void DI_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void DI_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void DI_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "plugins" && ns.empty ())
      {
        if (start)
        {
          if (this->plugins_parser_)
          {
            this->plugins_parser_->pre ();
            ctx.nested_parser (this->plugins_parser_);
          }
        }
        else
        {
          if (this->plugins_parser_ != 0)
          {
            ::plugins* tmp = this->plugins_parser_->post_plugins ();
            this->plugins (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "components" && ns.empty ())
      {
        if (start)
        {
          if (this->components_parser_)
          {
            this->components_parser_->pre ();
            ctx.nested_parser (this->components_parser_);
          }
        }
        else
        {
          if (this->components_parser_ != 0)
          {
            ::components* tmp = this->components_parser_->post_components ();
            this->components (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "wiring" && ns.empty ())
      {
        if (start)
        {
          if (this->wiring_parser_)
          {
            this->wiring_parser_->pre ();
            ctx.nested_parser (this->wiring_parser_);
          }
        }
        else
        {
          if (this->wiring_parser_ != 0)
          {
            ::wiring* tmp = this->wiring_parser_->post_wiring ();
            this->wiring (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for plugins_pskel.
//
bool plugins_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "shared" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &plugins_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool plugins_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void plugins_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void plugins_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void plugins_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "shared" && ns.empty ())
      {
        if (start)
        {
          if (this->shared_parser_)
          {
            this->shared_parser_->pre ();
            ctx.nested_parser (this->shared_parser_);
          }
        }
        else
        {
          if (this->shared_parser_ != 0)
          {
            const ::shared& tmp = this->shared_parser_->post_shared ();
            this->shared (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for components_pskel.
//
bool components_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "component" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &components_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool components_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void components_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void components_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void components_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "component" && ns.empty ())
      {
        if (start)
        {
          if (this->component_parser_)
          {
            this->component_parser_->pre ();
            ctx.nested_parser (this->component_parser_);
          }
        }
        else
        {
          if (this->component_parser_ != 0)
          {
            ::component* tmp = this->component_parser_->post_component ();
            this->component (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for wiring_pskel.
//
bool wiring_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "inject" && ns.empty ())
        s = 0UL;
      else if (n == "inject-all" && ns.empty ())
        s = 1UL;
      else if (n == "inject-one" && ns.empty ())
        s = 2UL;
      else if (n == "inject-slot" && ns.empty ())
        s = 3UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &wiring_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool wiring_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void wiring_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void wiring_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void wiring_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "inject" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_parser_)
          {
            this->inject_parser_->pre ();
            ctx.nested_parser (this->inject_parser_);
          }
        }
        else
        {
          if (this->inject_parser_ != 0)
          {
            const ::inject& tmp = this->inject_parser_->post_inject ();
            this->inject (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "inject-all" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_all_parser_)
          {
            this->inject_all_parser_->pre ();
            ctx.nested_parser (this->inject_all_parser_);
          }
        }
        else
        {
          if (this->inject_all_parser_ != 0)
          {
            ::inject_all* tmp = this->inject_all_parser_->post_inject_all ();
            this->inject_all (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "inject-one" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_one_parser_)
          {
            this->inject_one_parser_->pre ();
            ctx.nested_parser (this->inject_one_parser_);
          }
        }
        else
        {
          if (this->inject_one_parser_ != 0)
          {
            ::inject_one* tmp = this->inject_one_parser_->post_inject_one ();
            this->inject_one (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "inject-slot" && ns.empty ())
      {
        if (start)
        {
          if (this->inject_slot_parser_)
          {
            this->inject_slot_parser_->pre ();
            ctx.nested_parser (this->inject_slot_parser_);
          }
        }
        else
        {
          if (this->inject_slot_parser_ != 0)
          {
            const ::inject_slot& tmp = this->inject_slot_parser_->post_inject_slot ();
            this->inject_slot (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Attribute validation and dispatch functions for insert_pskel.
//
bool insert_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->value_parser_->post_string ();

        this->value (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
    return true;
  }

  return false;
}

void insert_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.value = false;
}

void insert_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.value)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for attribute_type_pskel.
//
bool attribute_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_token ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->value_parser_->post_string ();

        this->value (tmp);
      }
    }

    return true;
  }

  return false;
}

void attribute_type_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.name = false;
}

void attribute_type_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for param_type_pskel.
//
bool param_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
    {
      this->type_parser_->pre ();

      this->type_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->type_parser_->_characters (s);

      if (!ctx.error_type ())
        this->type_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::param_class_type& tmp = this->type_parser_->post_param_class_type ();

        this->type (tmp);
      }
    }

    return true;
  }

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->value_parser_->post_string ();

        this->value (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for inject_one_type_pskel.
//
bool inject_one_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "injection" && ns.empty ())
  {
    if (this->injection_parser_)
    {
      this->injection_parser_->pre ();

      this->injection_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->injection_parser_->_characters (s);

      if (!ctx.error_type ())
        this->injection_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->injection_parser_->post_token ();

        this->injection (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->injection = true;
    return true;
  }

  if (n == "slot" && ns.empty ())
  {
    if (this->slot_parser_)
    {
      this->slot_parser_->pre ();

      this->slot_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->slot_parser_->_characters (s);

      if (!ctx.error_type ())
        this->slot_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->slot_parser_->post_token ();

        this->slot (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->slot = true;
    return true;
  }

  return false;
}

void inject_one_type_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.injection = false;
  as.slot = false;
}

void inject_one_type_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.injection)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.slot)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for inject_all_type_pskel.
//
bool inject_all_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "receiver" && ns.empty ())
  {
    if (this->receiver_parser_)
    {
      this->receiver_parser_->pre ();

      this->receiver_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->receiver_parser_->_characters (s);

      if (!ctx.error_type ())
        this->receiver_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->receiver_parser_->post_token ();

        this->receiver (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->receiver = true;
    return true;
  }

  if (n == "slot" && ns.empty ())
  {
    if (this->slot_parser_)
    {
      this->slot_parser_->pre ();

      this->slot_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->slot_parser_->_characters (s);

      if (!ctx.error_type ())
        this->slot_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->slot_parser_->post_token ();

        this->slot (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->slot = true;
    return true;
  }

  return false;
}

void inject_all_type_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.receiver = false;
  as.slot = false;
}

void inject_all_type_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.receiver)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.slot)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for component_pskel.
//
bool component_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_token ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  if (n == "class" && ns.empty ())
  {
    if (this->class__parser_)
    {
      this->class__parser_->pre ();

      this->class__parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->class__parser_->_characters (s);

      if (!ctx.error_type ())
        this->class__parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->class__parser_->post_token ();

        this->class_ (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->class_ = true;
    return true;
  }

  return false;
}

void component_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.name = false;
  as.class_ = false;
}

void component_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.class_)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for inject_pskel.
//
bool inject_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "receiver" && ns.empty ())
  {
    if (this->receiver_parser_)
    {
      this->receiver_parser_->pre ();

      this->receiver_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->receiver_parser_->_characters (s);

      if (!ctx.error_type ())
        this->receiver_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->receiver_parser_->post_token ();

        this->receiver (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->receiver = true;
    return true;
  }

  if (n == "injection" && ns.empty ())
  {
    if (this->injection_parser_)
    {
      this->injection_parser_->pre ();

      this->injection_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->injection_parser_->_characters (s);

      if (!ctx.error_type ())
        this->injection_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->injection_parser_->post_token ();

        this->injection (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->injection = true;
    return true;
  }

  if (n == "slot" && ns.empty ())
  {
    if (this->slot_parser_)
    {
      this->slot_parser_->pre ();

      this->slot_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->slot_parser_->_characters (s);

      if (!ctx.error_type ())
        this->slot_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->slot_parser_->post_token ();

        this->slot (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->slot = true;
    return true;
  }

  return false;
}

void inject_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.receiver = false;
  as.injection = false;
  as.slot = false;
}

void inject_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.receiver)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.injection)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.slot)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for inject_one_pskel.
//
bool inject_one_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "receiver" && ns.empty ())
  {
    if (this->receiver_parser_)
    {
      this->receiver_parser_->pre ();

      this->receiver_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->receiver_parser_->_characters (s);

      if (!ctx.error_type ())
        this->receiver_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->receiver_parser_->post_token ();

        this->receiver (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->receiver = true;
    return true;
  }

  return false;
}

void inject_one_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.receiver = false;
}

void inject_one_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.receiver)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for inject_all_pskel.
//
bool inject_all_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "injection" && ns.empty ())
  {
    if (this->injection_parser_)
    {
      this->injection_parser_->pre ();

      this->injection_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->injection_parser_->_characters (s);

      if (!ctx.error_type ())
        this->injection_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->injection_parser_->post_token ();

        this->injection (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->injection = true;
    return true;
  }

  return false;
}

void inject_all_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.injection = false;
}

void inject_all_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.injection)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for inject_slot_pskel.
//
bool inject_slot_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "slot" && ns.empty ())
  {
    if (this->slot_parser_)
    {
      this->slot_parser_->pre ();

      this->slot_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->slot_parser_->_characters (s);

      if (!ctx.error_type ())
        this->slot_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->slot_parser_->post_token ();

        this->slot (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->slot = true;
    return true;
  }

  if (n == "injection" && ns.empty ())
  {
    if (this->injection_parser_)
    {
      this->injection_parser_->pre ();

      this->injection_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->injection_parser_->_characters (s);

      if (!ctx.error_type ())
        this->injection_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->injection_parser_->post_token ();

        this->injection (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->injection = true;
    return true;
  }

  return false;
}

void inject_slot_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.slot = false;
  as.injection = false;
}

void inject_slot_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.slot)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.injection)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for shared_pskel.
//
bool shared_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "lib" && ns.empty ())
  {
    if (this->lib_parser_)
    {
      this->lib_parser_->pre ();

      this->lib_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->lib_parser_->_characters (s);

      if (!ctx.error_type ())
        this->lib_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->lib_parser_->post_name ();

        this->lib (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lib = true;
    return true;
  }

  return false;
}

void shared_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.lib = false;
}

void shared_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.lib)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Begin epilogue.
//
//
// End epilogue.

