// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "di.hxx"

// param_class_type
//

param_class_type::
param_class_type ()
{
}

param_class_type::
param_class_type (value_type v)
{
  value_ = v;
}

void param_class_type::
value (value_type v)
{
  value_ = v;
}

// insert
//

const ::std::string& insert::
value () const
{
  return this->value_;
}

::std::string& insert::
value ()
{
  return this->value_;
}

void insert::
value (const ::std::string& x)
{
  this->value_ = x;
}

// attribute_type
//

const ::std::string& attribute_type::
name () const
{
  return this->name_;
}

::std::string& attribute_type::
name ()
{
  return this->name_;
}

void attribute_type::
name (const ::std::string& x)
{
  this->name_ = x;
}

bool attribute_type::
value_present () const
{
  return this->value_present_;
}

void attribute_type::
value_present (bool x)
{
  this->value_present_ = x;
}

const ::std::string& attribute_type::
value () const
{
  return this->value_;
}

::std::string& attribute_type::
value ()
{
  return this->value_;
}

void attribute_type::
value (const ::std::string& x)
{
  this->value_ = x;
  this->value_present_ = true;
}

const attribute_type::insert_sequence& attribute_type::
insert () const
{
  return this->insert_;
}

attribute_type::insert_sequence& attribute_type::
insert ()
{
  return this->insert_;
}

// param_type
//

bool param_type::
type_present () const
{
  return this->type_present_;
}

void param_type::
type_present (bool x)
{
  this->type_present_ = x;
}

const ::param_class_type& param_type::
type () const
{
  return this->type_;
}

::param_class_type& param_type::
type ()
{
  return this->type_;
}

void param_type::
type (const ::param_class_type& x)
{
  this->type_ = x;
  this->type_present_ = true;
}

bool param_type::
value_present () const
{
  return this->value_present_;
}

void param_type::
value_present (bool x)
{
  this->value_present_ = x;
}

const ::std::string& param_type::
value () const
{
  return this->value_;
}

::std::string& param_type::
value ()
{
  return this->value_;
}

void param_type::
value (const ::std::string& x)
{
  this->value_ = x;
  this->value_present_ = true;
}

// inject_one_type
//

const ::std::string& inject_one_type::
injection () const
{
  return this->injection_;
}

::std::string& inject_one_type::
injection ()
{
  return this->injection_;
}

void inject_one_type::
injection (const ::std::string& x)
{
  this->injection_ = x;
}

const ::std::string& inject_one_type::
slot () const
{
  return this->slot_;
}

::std::string& inject_one_type::
slot ()
{
  return this->slot_;
}

void inject_one_type::
slot (const ::std::string& x)
{
  this->slot_ = x;
}

// inject_all_type
//

const ::std::string& inject_all_type::
receiver () const
{
  return this->receiver_;
}

::std::string& inject_all_type::
receiver ()
{
  return this->receiver_;
}

void inject_all_type::
receiver (const ::std::string& x)
{
  this->receiver_ = x;
}

const ::std::string& inject_all_type::
slot () const
{
  return this->slot_;
}

::std::string& inject_all_type::
slot ()
{
  return this->slot_;
}

void inject_all_type::
slot (const ::std::string& x)
{
  this->slot_ = x;
}

// component
//

const ::std::string& component::
name () const
{
  return this->name_;
}

::std::string& component::
name ()
{
  return this->name_;
}

void component::
name (const ::std::string& x)
{
  this->name_ = x;
}

const ::std::string& component::
class_ () const
{
  return this->class__;
}

::std::string& component::
class_ ()
{
  return this->class__;
}

void component::
class_ (const ::std::string& x)
{
  this->class__ = x;
}

const component::attribute_sequence& component::
attribute () const
{
  return this->attribute_;
}

component::attribute_sequence& component::
attribute ()
{
  return this->attribute_;
}

// inject
//

const ::std::string& inject::
receiver () const
{
  return this->receiver_;
}

::std::string& inject::
receiver ()
{
  return this->receiver_;
}

void inject::
receiver (const ::std::string& x)
{
  this->receiver_ = x;
}

const ::std::string& inject::
injection () const
{
  return this->injection_;
}

::std::string& inject::
injection ()
{
  return this->injection_;
}

void inject::
injection (const ::std::string& x)
{
  this->injection_ = x;
}

const ::std::string& inject::
slot () const
{
  return this->slot_;
}

::std::string& inject::
slot ()
{
  return this->slot_;
}

void inject::
slot (const ::std::string& x)
{
  this->slot_ = x;
}

// inject-one
//

const ::std::string& inject_one::
receiver () const
{
  return this->receiver_;
}

::std::string& inject_one::
receiver ()
{
  return this->receiver_;
}

void inject_one::
receiver (const ::std::string& x)
{
  this->receiver_ = x;
}

const inject_one::inject_sequence& inject_one::
inject () const
{
  return this->inject_;
}

inject_one::inject_sequence& inject_one::
inject ()
{
  return this->inject_;
}

// inject-all
//

const ::std::string& inject_all::
injection () const
{
  return this->injection_;
}

::std::string& inject_all::
injection ()
{
  return this->injection_;
}

void inject_all::
injection (const ::std::string& x)
{
  this->injection_ = x;
}

const inject_all::inject_sequence& inject_all::
inject () const
{
  return this->inject_;
}

inject_all::inject_sequence& inject_all::
inject ()
{
  return this->inject_;
}

// inject-slot
//

const ::std::string& inject_slot::
slot () const
{
  return this->slot_;
}

::std::string& inject_slot::
slot ()
{
  return this->slot_;
}

void inject_slot::
slot (const ::std::string& x)
{
  this->slot_ = x;
}

const ::std::string& inject_slot::
injection () const
{
  return this->injection_;
}

::std::string& inject_slot::
injection ()
{
  return this->injection_;
}

void inject_slot::
injection (const ::std::string& x)
{
  this->injection_ = x;
}

// DI
//

bool DI::
plugins_present () const
{
  return this->plugins_ != 0;
}

const ::plugins& DI::
plugins () const
{
  return *this->plugins_;
}

::plugins& DI::
plugins ()
{
  return *this->plugins_;
}

void DI::
plugins (::plugins* x)
{
  delete this->plugins_;
  this->plugins_ = x;
}

bool DI::
components_present () const
{
  return this->components_ != 0;
}

const ::components& DI::
components () const
{
  return *this->components_;
}

::components& DI::
components ()
{
  return *this->components_;
}

void DI::
components (::components* x)
{
  delete this->components_;
  this->components_ = x;
}

bool DI::
wiring_present () const
{
  return this->wiring_ != 0;
}

const ::wiring& DI::
wiring () const
{
  return *this->wiring_;
}

::wiring& DI::
wiring ()
{
  return *this->wiring_;
}

void DI::
wiring (::wiring* x)
{
  delete this->wiring_;
  this->wiring_ = x;
}

// shared
//

const ::std::string& shared::
lib () const
{
  return this->lib_;
}

::std::string& shared::
lib ()
{
  return this->lib_;
}

void shared::
lib (const ::std::string& x)
{
  this->lib_ = x;
}

// plugins
//

const plugins::shared_sequence& plugins::
shared () const
{
  return this->shared_;
}

plugins::shared_sequence& plugins::
shared ()
{
  return this->shared_;
}

// components
//

const components::component_sequence& components::
component () const
{
  return this->component_;
}

components::component_sequence& components::
component ()
{
  return this->component_;
}

// wiring
//

const wiring::inject_sequence& wiring::
inject () const
{
  return this->inject_;
}

wiring::inject_sequence& wiring::
inject ()
{
  return this->inject_;
}

const wiring::inject_all_sequence& wiring::
inject_all () const
{
  return this->inject_all_;
}

wiring::inject_all_sequence& wiring::
inject_all ()
{
  return this->inject_all_;
}

const wiring::inject_one_sequence& wiring::
inject_one () const
{
  return this->inject_one_;
}

wiring::inject_one_sequence& wiring::
inject_one ()
{
  return this->inject_one_;
}

const wiring::inject_slot_sequence& wiring::
inject_slot () const
{
  return this->inject_slot_;
}

wiring::inject_slot_sequence& wiring::
inject_slot ()
{
  return this->inject_slot_;
}

#include <stdlib.h>
#include <new>

// param_class_type
//

static const char* _xsde_param_class_type_enumerators_[] = 
{
  "char",
  "unsigned char",
  "int",
  "unsigned int",
  "long",
  "double",
  "bool",
  "string"
};

const char* param_class_type::
string1 () const
{
  return _xsde_param_class_type_enumerators_[value_];
}

// insert
//

insert::
insert ()
{
}

insert::
~insert ()
{
}

insert::
insert (const insert& x)
{
  XSDE_UNUSED (x);
  this->value_ = x.value_;
}

insert& insert::
operator= (const insert& x)
{
  XSDE_UNUSED (x);
  this->value_ = x.value_;
  return *this;
}

// attribute_type
//

attribute_type::
attribute_type ()
{
  this->value_present_ = false;
}

attribute_type::
~attribute_type ()
{
}

// param_type
//

param_type::
param_type ()
{
  this->type_present_ = false;
  this->value_present_ = false;
}

param_type::
~param_type ()
{
}

param_type::
param_type (const param_type& x)
{
  XSDE_UNUSED (x);
  this->type_present_ = x.type_present_;
  if (this->type_present_)
    this->type_ = x.type_;
  this->value_present_ = x.value_present_;
  if (this->value_present_)
    this->value_ = x.value_;
}

param_type& param_type::
operator= (const param_type& x)
{
  XSDE_UNUSED (x);
  this->type_present_ = x.type_present_;
  if (this->type_present_)
    this->type_ = x.type_;
  this->value_present_ = x.value_present_;
  if (this->value_present_)
    this->value_ = x.value_;
  return *this;
}

// inject_one_type
//

inject_one_type::
inject_one_type ()
{
}

inject_one_type::
~inject_one_type ()
{
}

inject_one_type::
inject_one_type (const inject_one_type& x)
{
  XSDE_UNUSED (x);
  this->injection_ = x.injection_;
  this->slot_ = x.slot_;
}

inject_one_type& inject_one_type::
operator= (const inject_one_type& x)
{
  XSDE_UNUSED (x);
  this->injection_ = x.injection_;
  this->slot_ = x.slot_;
  return *this;
}

// inject_all_type
//

inject_all_type::
inject_all_type ()
{
}

inject_all_type::
~inject_all_type ()
{
}

inject_all_type::
inject_all_type (const inject_all_type& x)
{
  XSDE_UNUSED (x);
  this->receiver_ = x.receiver_;
  this->slot_ = x.slot_;
}

inject_all_type& inject_all_type::
operator= (const inject_all_type& x)
{
  XSDE_UNUSED (x);
  this->receiver_ = x.receiver_;
  this->slot_ = x.slot_;
  return *this;
}

// component
//

component::
component ()
{
}

component::
~component ()
{
}

// inject
//

inject::
inject ()
{
}

inject::
~inject ()
{
}

inject::
inject (const inject& x)
{
  XSDE_UNUSED (x);
  this->receiver_ = x.receiver_;
  this->injection_ = x.injection_;
  this->slot_ = x.slot_;
}

inject& inject::
operator= (const inject& x)
{
  XSDE_UNUSED (x);
  this->receiver_ = x.receiver_;
  this->injection_ = x.injection_;
  this->slot_ = x.slot_;
  return *this;
}

// inject-one
//

inject_one::
inject_one ()
{
}

inject_one::
~inject_one ()
{
}

// inject-all
//

inject_all::
inject_all ()
{
}

inject_all::
~inject_all ()
{
}

// inject-slot
//

inject_slot::
inject_slot ()
{
}

inject_slot::
~inject_slot ()
{
}

inject_slot::
inject_slot (const inject_slot& x)
{
  XSDE_UNUSED (x);
  this->slot_ = x.slot_;
  this->injection_ = x.injection_;
}

inject_slot& inject_slot::
operator= (const inject_slot& x)
{
  XSDE_UNUSED (x);
  this->slot_ = x.slot_;
  this->injection_ = x.injection_;
  return *this;
}

// DI
//

DI::
DI ()
{
  this->plugins_ = 0;
  this->components_ = 0;
  this->wiring_ = 0;
}

DI::
~DI ()
{
  delete this->plugins_;
  delete this->components_;
  delete this->wiring_;
}

// shared
//

shared::
shared ()
{
}

shared::
~shared ()
{
}

shared::
shared (const shared& x)
{
  XSDE_UNUSED (x);
  this->lib_ = x.lib_;
}

shared& shared::
operator= (const shared& x)
{
  XSDE_UNUSED (x);
  this->lib_ = x.lib_;
  return *this;
}

// plugins
//

plugins::
plugins ()
{
}

plugins::
~plugins ()
{
}

// components
//

components::
components ()
{
}

components::
~components ()
{
}

// wiring
//

wiring::
wiring ()
{
}

wiring::
~wiring ()
{
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

