// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef E__VS14PRJBKP_ENGINE_DI_DI_HXX
#define E__VS14PRJBKP_ENGINE_DI_DI_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class param_class_type;
class insert;
class attribute_type;
class param_type;
class inject_one_type;
class inject_all_type;
class component;
class inject;
class inject_one;
class inject_all;
class inject_slot;
class DI;
class shared;
class plugins;
class components;
class wiring;

// param_class_type (fixed-length)
//
class param_class_type
{
  public:
  enum value_type
  {
    char_,
    unsigned_char,
    int_,
    unsigned_int,
    long_,
    double_,
    bool_,
    string
  };

  param_class_type ();
  param_class_type (value_type);

  void
  value (value_type);

  operator value_type () const
  {
    return value_;
  }

  const char*
  string1 () const;

  private:
  value_type value_;
};

// insert (fixed-length)
//
class insert
{
  public:
  insert ();

  insert (const insert&);
  insert& operator= (const insert&);

  ~insert ();

  // value
  //
  const ::std::string&
  value () const;

  ::std::string&
  value ();

  void
  value (const ::std::string&);

  private:
  ::std::string value_;
};

// attribute_type (variable-length)
//
class attribute_type
{
  private:
  attribute_type (const attribute_type&);
  attribute_type& operator= (const attribute_type&);

  public:
  attribute_type ();

  ~attribute_type ();

  // name
  //
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // value
  //
  bool
  value_present () const;

  void
  value_present (bool);

  const ::std::string&
  value () const;

  ::std::string&
  value ();

  void
  value (const ::std::string&);

  // insert
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::insert > insert_sequence;
  typedef insert_sequence::iterator insert_iterator;
  typedef insert_sequence::const_iterator insert_const_iterator;

  const insert_sequence&
  insert () const;

  insert_sequence&
  insert ();

  private:
  ::std::string name_;
  ::std::string value_;
  unsigned char value_present_;
  insert_sequence insert_;
};

// param_type (fixed-length)
//
class param_type
{
  public:
  param_type ();

  param_type (const param_type&);
  param_type& operator= (const param_type&);

  ~param_type ();

  // type
  //
  bool
  type_present () const;

  void
  type_present (bool);

  const ::param_class_type&
  type () const;

  ::param_class_type&
  type ();

  void
  type (const ::param_class_type&);

  // value
  //
  bool
  value_present () const;

  void
  value_present (bool);

  const ::std::string&
  value () const;

  ::std::string&
  value ();

  void
  value (const ::std::string&);

  private:
  ::param_class_type type_;
  unsigned char type_present_;
  ::std::string value_;
  unsigned char value_present_;
};

// inject_one_type (fixed-length)
//
class inject_one_type
{
  public:
  inject_one_type ();

  inject_one_type (const inject_one_type&);
  inject_one_type& operator= (const inject_one_type&);

  ~inject_one_type ();

  // injection
  //
  const ::std::string&
  injection () const;

  ::std::string&
  injection ();

  void
  injection (const ::std::string&);

  // slot
  //
  const ::std::string&
  slot () const;

  ::std::string&
  slot ();

  void
  slot (const ::std::string&);

  private:
  ::std::string injection_;
  ::std::string slot_;
};

// inject_all_type (fixed-length)
//
class inject_all_type
{
  public:
  inject_all_type ();

  inject_all_type (const inject_all_type&);
  inject_all_type& operator= (const inject_all_type&);

  ~inject_all_type ();

  // receiver
  //
  const ::std::string&
  receiver () const;

  ::std::string&
  receiver ();

  void
  receiver (const ::std::string&);

  // slot
  //
  const ::std::string&
  slot () const;

  ::std::string&
  slot ();

  void
  slot (const ::std::string&);

  private:
  ::std::string receiver_;
  ::std::string slot_;
};

// component (variable-length)
//
class component
{
  private:
  component (const component&);
  component& operator= (const component&);

  public:
  component ();

  ~component ();

  // name
  //
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // class
  //
  const ::std::string&
  class_ () const;

  ::std::string&
  class_ ();

  void
  class_ (const ::std::string&);

  // attribute
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::attribute_type > attribute_sequence;
  typedef attribute_sequence::iterator attribute_iterator;
  typedef attribute_sequence::const_iterator attribute_const_iterator;

  const attribute_sequence&
  attribute () const;

  attribute_sequence&
  attribute ();

  private:
  ::std::string name_;
  ::std::string class__;
  attribute_sequence attribute_;
};

// inject (fixed-length)
//
class inject
{
  public:
  inject ();

  inject (const inject&);
  inject& operator= (const inject&);

  ~inject ();

  // receiver
  //
  const ::std::string&
  receiver () const;

  ::std::string&
  receiver ();

  void
  receiver (const ::std::string&);

  // injection
  //
  const ::std::string&
  injection () const;

  ::std::string&
  injection ();

  void
  injection (const ::std::string&);

  // slot
  //
  const ::std::string&
  slot () const;

  ::std::string&
  slot ();

  void
  slot (const ::std::string&);

  private:
  ::std::string receiver_;
  ::std::string injection_;
  ::std::string slot_;
};

// inject-one (variable-length)
//
class inject_one
{
  private:
  inject_one (const inject_one&);
  inject_one& operator= (const inject_one&);

  public:
  inject_one ();

  ~inject_one ();

  // receiver
  //
  const ::std::string&
  receiver () const;

  ::std::string&
  receiver ();

  void
  receiver (const ::std::string&);

  // inject
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::inject_one_type > inject_sequence;
  typedef inject_sequence::iterator inject_iterator;
  typedef inject_sequence::const_iterator inject_const_iterator;

  const inject_sequence&
  inject () const;

  inject_sequence&
  inject ();

  private:
  ::std::string receiver_;
  inject_sequence inject_;
};

// inject-all (variable-length)
//
class inject_all
{
  private:
  inject_all (const inject_all&);
  inject_all& operator= (const inject_all&);

  public:
  inject_all ();

  ~inject_all ();

  // injection
  //
  const ::std::string&
  injection () const;

  ::std::string&
  injection ();

  void
  injection (const ::std::string&);

  // inject
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::inject_all_type > inject_sequence;
  typedef inject_sequence::iterator inject_iterator;
  typedef inject_sequence::const_iterator inject_const_iterator;

  const inject_sequence&
  inject () const;

  inject_sequence&
  inject ();

  private:
  ::std::string injection_;
  inject_sequence inject_;
};

// inject-slot (fixed-length)
//
class inject_slot
{
  public:
  inject_slot ();

  inject_slot (const inject_slot&);
  inject_slot& operator= (const inject_slot&);

  ~inject_slot ();

  // slot
  //
  const ::std::string&
  slot () const;

  ::std::string&
  slot ();

  void
  slot (const ::std::string&);

  // injection
  //
  const ::std::string&
  injection () const;

  ::std::string&
  injection ();

  void
  injection (const ::std::string&);

  private:
  ::std::string slot_;
  ::std::string injection_;
};

// DI (variable-length)
//
class DI
{
  private:
  DI (const DI&);
  DI& operator= (const DI&);

  public:
  DI ();

  ~DI ();

  // plugins
  //
  bool
  plugins_present () const;

  const ::plugins&
  plugins () const;

  ::plugins&
  plugins ();

  void
  plugins (::plugins*);

  // components
  //
  bool
  components_present () const;

  const ::components&
  components () const;

  ::components&
  components ();

  void
  components (::components*);

  // wiring
  //
  bool
  wiring_present () const;

  const ::wiring&
  wiring () const;

  ::wiring&
  wiring ();

  void
  wiring (::wiring*);

  private:
  ::plugins* plugins_;
  ::components* components_;
  ::wiring* wiring_;
};

// shared (fixed-length)
//
class shared
{
  public:
  shared ();

  shared (const shared&);
  shared& operator= (const shared&);

  ~shared ();

  // lib
  //
  const ::std::string&
  lib () const;

  ::std::string&
  lib ();

  void
  lib (const ::std::string&);

  private:
  ::std::string lib_;
};

// plugins (variable-length)
//
class plugins
{
  private:
  plugins (const plugins&);
  plugins& operator= (const plugins&);

  public:
  plugins ();

  ~plugins ();

  // shared
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::shared > shared_sequence;
  typedef shared_sequence::iterator shared_iterator;
  typedef shared_sequence::const_iterator shared_const_iterator;

  const shared_sequence&
  shared () const;

  shared_sequence&
  shared ();

  private:
  shared_sequence shared_;
};

// components (variable-length)
//
class components
{
  private:
  components (const components&);
  components& operator= (const components&);

  public:
  components ();

  ~components ();

  // component
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::component > component_sequence;
  typedef component_sequence::iterator component_iterator;
  typedef component_sequence::const_iterator component_const_iterator;

  const component_sequence&
  component () const;

  component_sequence&
  component ();

  private:
  component_sequence component_;
};

// wiring (variable-length)
//
class wiring
{
  private:
  wiring (const wiring&);
  wiring& operator= (const wiring&);

  public:
  wiring ();

  ~wiring ();

  // inject
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::inject > inject_sequence;
  typedef inject_sequence::iterator inject_iterator;
  typedef inject_sequence::const_iterator inject_const_iterator;

  const inject_sequence&
  inject () const;

  inject_sequence&
  inject ();

  // inject-all
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::inject_all > inject_all_sequence;
  typedef inject_all_sequence::iterator inject_all_iterator;
  typedef inject_all_sequence::const_iterator inject_all_const_iterator;

  const inject_all_sequence&
  inject_all () const;

  inject_all_sequence&
  inject_all ();

  // inject-one
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::inject_one > inject_one_sequence;
  typedef inject_one_sequence::iterator inject_one_iterator;
  typedef inject_one_sequence::const_iterator inject_one_const_iterator;

  const inject_one_sequence&
  inject_one () const;

  inject_one_sequence&
  inject_one ();

  // inject-slot
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::inject_slot > inject_slot_sequence;
  typedef inject_slot_sequence::iterator inject_slot_iterator;
  typedef inject_slot_sequence::const_iterator inject_slot_const_iterator;

  const inject_slot_sequence&
  inject_slot () const;

  inject_slot_sequence&
  inject_slot ();

  private:
  inject_sequence inject_;
  inject_all_sequence inject_all_;
  inject_one_sequence inject_one_;
  inject_slot_sequence inject_slot_;
};

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // E__VS14PRJBKP_ENGINE_DI_DI_HXX
