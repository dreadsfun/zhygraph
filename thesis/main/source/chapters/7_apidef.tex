\Chapter{A keretrendszer használata és a szkript felület}
\label{Chap:api}

Ebben a részben találhatunk információkat azt illetõen, hogy hogyan is kezdhetünk el fejleszteni a keretrendszer segítségével és, hogy milyen funkciók vannak biztosítva a szkript környezeten keresztül.

\Section{Szükséges fájlok}
\SubSection{Alacsony szintû konfiguráció}
A \textit{main/engine.conf} útvonalon található fájl tartalmazza a rendszer különbözõ komponenseinek paramétereit, és azok függõségeit. Itt találhatóak továbbá a nyílvántartó rendszer számára biztosított tartalom-deklarációk is.

Ahhoz, hogy egy tartalom, például egy textúra, felhasználható legyen a rendszer számára, szerepelnie kell az adott típus felsorolásában. Tegyük fel például, hogy a \textit{grass.png} nevû textúrát szeretnénk elérhetõvé tenni. Elsõ lépésként eltávolítjuk a fájl kiterjesztését, mert a pont karakter útvonal elválasztóként viselkedik az absztraktált fájlrendszerben.

Következõ lépésben megkeressük a konfigurációs fájlban, a tartalom típusához tartozó nyílvántartó osztályt. Jelen esetben ez a \textit{texture\_manager} lesz, hiszen egy textúrát kívánunk deklarálni. Minden nyílvántartó osztály rendelkezik az \textit{assets} tömb attribútummal, ebbe kell elhelyeznünk a kívánt értékeket. Tehát a kívánt textúra deklarálása a következõ lesz:

\begin{xml}
<component name="texture_manager" class="texture_manager">
  <attribute name="assets">
    <insert value="texture@grass"/>
  </attribute>
</component>
\end{xml}

A beillesztett érték formátuma általánosan: \textit{tartalomtípus@útvonal}. Minden más típusú tartalomra hasonló az eljárás, például egy geometriai objektum deklarálása a következõ lehet:

\begin{xml}
<component name="mesh_manager" class="mesh_manager">
  <attribute name="assets"> 
    <insert value="mesh@terrain"/>
  </attribute>
</component>
\end{xml}

További gyakori felhasználása lehet még ennek a konfigurációs fájlnak az üzenetküldési csatornák leírása. Például az üzenetek fájlba írányítása a következõ komponens deklarációval történik:

\begin{xml}
<component name="n_file_channel" class="file_channel">
  <attribute name="file" value="engine.log"/>
</component>
\end{xml}

Az \textit{engine.log} a fájl útvonala, ahova az üzenetek kerülnek majd, ezen a csatornán keresztül.

A további komponensek deklarációja és injektálása akkor lehet fontos ha a keretrendszert tovább kívánjuk fejleszteni.

\SubSection{Anyag tulajdonságok deklarációja}
A \textit{main/materials} útvonalon található fájlban láthatjuk az úgy nevezett \textit{material} deklarációkat. Ezek olyan objektumok, amik meghatározzák, hogy egy adott geometriai objektumot milyen grafikus "árnyékoló" programmal és milyen textúrákkal kell kirajzolni.

Például ha szeretnénk felhasználni az elõzõleg deklarált textúrát, akkor ez lehet a tartalma a fájlnak:

\begin{xml}
<materials>
	<material name="grass_texture">
		<shader file="text@standardfs"/>
	  <texture sampler="albedo_map" file="texture@grass"/>
  </material>
</materials>
\end{xml}

A fájlnak mindig \textit{materials} taggal kell kezdõdnie, ezen belül kell felsorolni a különbözõ material objektumok deklarációit. Az elsõ paraméter, a \textit{name} az objektum nevét határozza meg, késõbb ezzel hivatkozhatunk majd rá. A \textit{shader} tagban meghatározott fájl, a grafikus árnyékoló program elérési útvonala. A textúrához hasonlóan ennek is deklarálva kell lennie a nyílvántartó rendszer valamely komponensében. Az utolsó sor azt határozza meg, hogy az úgy nevezett \textit{albedo\_map} (az objektum alap színét ez határozza meg) textúra típushoz, az elõzõleg bevezetett fû textúrát rendeljük.

\SubSection{Virtuális tér fagráf definíciók}
A \textit{main/scenes} fájlban kell leírni a már ismertetett virtuális fagráf szerkezetét. A fájl struktúrája úgy van kialakítva, hogy elsõ lépésben a használni kívánt facsúcsokat deklaráljuk egymástól függetlenül, majd azt írjuk le, hogy egy konkrét jeleneten belül milyen kapcsolatban vannak ezek a csúcsok.

Képzeljük el ezt úgy, hogy egy gráfnak csak a pontjai adottak, az élei ismeretlenek és különbözõ gráfokat hozunk létre, különbözõ él-halmazok definiálásával. Azért elõnyös ez a megközelítés, mert elõfordulhatnak jelenetenként ismtélõdõ csúcsok, így azonban elegendõ egyszer definiálni õket.

Egy példa a fájl tartalmára a következõ:

\begin{xml}
<scene_graph>
  <nodes>
    <node name="camera" class="camera_node">
      <attribute name="projection_mode" value="perspective"/>
      <attribute name="aspect_ratio" value="1.33333"/>
      <attribute name="field_of_view" value="0.33333"/>
      <attribute name="near_clip" value="0.1"/>
      <attribute name="far_clip" value="500"/>
    </node>
    <node name="n1" class="mesh_renderer_node">
      <attribute name="mesh_url" value="mesh@terrain"/>
      <attribute name="materials" value="grass_texture"/>
    </node>
    <node name="n11" class="scene_node_base"/>
    <node name="n111" class="scene_node_base"/>
    <node name="n112" class="scene_node_base"/>
    <node name="n1121" class="scene_node_base"/>
    <node name="n12" class="scene_node_base"/>
    <node name="n13" class="scene_node_base"/>
    <node name="n14" class="scene_node_base"/>
    <node name="n141" class="scene_node_base"/>
    <node name="n142" class="scene_node_base"/>
  </nodes>
	
  <scenes>
    <scene name="scene1" 
      graph="camera n1 n11 n111 
        . n112 n1121 
        . . . n12 
        . n13 
        . n14 n141 
        . n142"/>
  </scenes>
</scene_graph>
\end{xml}

A fájl kezdõ tagja ismét fix, ezután következik a csúcsok felsorolása a \textit{nodes} tagon belül. Egy csúcs definiciójához mindenképpen szükséges egy név (\textit{name}) és egy típus (\textit{class}). A névvel hivatkozhatunk rájuk késõbb, a csúcskapcsolatok leírásakor vagy a szkriptekben történõ felhasználásukkor. A típusnak egy C++-ban létrehozott és \textit{reflektált} osztálynak kell lennie.

Láthatjuk, hogy szerepel egy csúcs, \textit{mesh\_renderer\_node} típussal. Ez egy olyan típusú csúcs, ami geometriai objektumokat képes megjeleníteni. A két megadott attribútuma a \textit{mesh\_url} és a \textit{materials}. Az elõbbi azt határozza meg, hogy melyik, a korábban látott módszerrel deklarált geometriai objektumot használja fel a csúcs. Az utóbbi pedig az anyagtulajdonságokat leíró material objektum neve, ahogy azt a \textit{materials} fájlban deklaráltuk.

A \textit{scenes} tagban kell felsorolnunk a különbözõ jelenetek (a csúcsok összekötésének különbözõ módjai) jellemzõit. A \textit{name} paraméter egy egyedi név, amivel késõbb hivatkozhatunk rá, a \textit{graph} paraméter pedig a használt csúcsok listáját, illetve kapcsolatát határozza meg. A kapcsolatok leírására a következõ szabály van érvényben: egy leírt csúcs mindig, az elõzõleg leírt csúcs gyermeke lesz, ha az létezik. Jelen esetben tehát a "camera" nevû csúcs a gyökér elem, annak gyermeke pedig az "n1" csúcs. Ha nem az utolsónak leírt csúcsot szeretnénk a következõ csúcs szülõjeként, akkor egy "." (pont) karaktert kell írnunk, ami egy visszalépést jelent. Így például az "n112" csúcs, nem az "n111" csúcs gyermeke lesz, hanem az "n11"-é. Az "n12" csúcs szülõje pedig az "n1" csúcs lesz.

\Section{Szkript funkciók}

\SubSection{Felhasználói interakció}

Különbözõ bemeneti eszközökrõl érkezõ jelekre reagálhatunk az itt tárgyalt funkciók segítségével. A \textit{py\_api/input.py} fájlban találhatóak a szükséges funkciók és értékek definíciói.

Az \textit{input} osztályba tartozó funkciók a következõek.

\begin{python}
get_key_down(key)
get_key_up(key)
get_key(key)
get_button_down(btn)
get_button_up(btn)
get_button(btn)
get_cursor_position()
get_cursor_displacement()
\end{python}

A \textit{get\_key*} család funkciói, a paraméterben megadott billentyû lenyomását, míg a \textit{get\_button*} funkciók az egér gombjainak állapotát jelzik. Mindegyik funkció logikai igazat vagy hamisat ad vissza az állapotoktól függõen. Mindkét funkció csoportra igaz, hogy a \textit{down} végzõdésüek pontosan egyszer térnek vissza igaz értékkel egy billentyû vagy gomb lenyomásakor, a \textit{up} végzõdésüek pontosan egyszer térnek vissza igaz értékkel egy billentyû vagy gomb felengedésekor, az "irány" jelzés nélküli funkciók pedig mindaddig igazzal térnek vissza, amíg az ellenõrzött billentyû vagy gomb le van nyomva.

A kurzor állapotához kapcsolódik a maradék két funkció: a \textit{position} a kurzor aktuális helyzetét adja meg két elemû, pixelben mért vektorban, relatíve a képernyõ helyzetéhez, úgy, hogy a képernyõ bal felsõ sarka az origó és jobbra illetve lefelé növekednek a tengelyek.

A \textit{displacement} (elmozdulás), a kurzor elõzõ alkalmazás frissítésben és a jelenlegi frissítésben mért helyzetének különbsége. Visszatérési értéke szintén két elemû vektor, mely értékei pixelben értendõk.

A billentyûk és gombok értékei, rendre a \textit{keys} és \textit{buttons} osztályban vannak definiálva. Ezeket kell paraméternek adnunk az elõzõleg tárgyalt funkcióknak, ha ellenõrizni szeretnénk az állapotukat.

\begin{python}
...
end = c_int.in_dll(lib, 'keys_end')
home = c_int.in_dll(lib, 'keys_home')
left = c_int.in_dll(lib, 'keys_left')
...
f7 = c_int.in_dll(lib, 'keys_f7')
f8 = c_int.in_dll(lib, 'keys_f8')
f9 = c_int.in_dll(lib, 'keys_f9')
...
o = c_int.in_dll(lib, 'keys_o')
p = c_int.in_dll(lib, 'keys_p')
q = c_int.in_dll(lib, 'keys_q')
...
right = c_int.in_dll(lib, 'buttons_right')
middle = c_int.in_dll(lib, 'buttons_middle')
...
\end{python}

Például ha az "A" billentyû lenyomására szeretnénk reagálni:

\begin{python}
if get_key_down(keys.a):
  print "key A was pressed"
\end{python} 

\SubSection{Fagráf manipuláció és transzformációk}

A \textit{py\_api/transform.py} fájlban található a \textit{transform} osztály, ami a virtuális tér csúcsaihoz tartozó transzformációs funkciókat foglalja magába.

A funkciók legnagyobb része a csúcsokat leíró paraméterek manipulálására jött létre. Ezek a paraméterek az orientáció, skálázás és a pozíció. A funkciók tovább bonthatóak az alapján, hogy milyen koordináta-rendszerben operálnak. Ez lehet "világ", tehát az abszolút bázis, vagy "lokális", tehát a csúcs szülõjéhez viszonyított rendszerben értelmezett. Bizonyos esetekben különbözõ funkciók állnak rendelkezésre a két viszonyítási rendszer használatára, bizonyos esetekben pedig paraméterként adhatjuk meg a kívánt bázist:

\begin{python}
class coordinate_space(Enum):
  world = 0
  local = 1
\end{python}

Továbbá, a paraméterek közvetlen eléréséhez rendelkezésre állnak lekérdezõ ("getter") és beállító ("setter") funkciók. Így például a pozícióhoz kapcsolódó funkciók a következõképpen alakulnak:

\begin{python}
@property
local_position(self)

@local_position.setter
local_position(self, pos)

@property
get_position(self)

@position.setter
set_position(self, pos)
\end{python}

A további paraméterekre, az orientációra (\textit{rotation}) és skálázásra (\textit{scale}) vonatkozó funkciók is ezen analógia alapján kerültek kialakításra.

A további funkciók különbözõ térbeli transzformációkat, számításokat valósítanak meg, mint például egy tetszõleges pont vagy vektor lokális bázisból, abszolút bázisba történõ (vagy fordítva) konvertálása, illetve pont körüli forgatás, vagy eltolás:

\begin{python}
transform_position(self, pos):
...
inverse_transform_direction(self, dirc)
...
translate(self, dirc, space = coordinate_space.world)
...
rotate_around(self, cent, axis, angle, look = False)
\end{python}

\SubSection{Megjelenítési funkciók}