\Chapter{Optimalizált grafikus megjelenítés}
\label{Chap:grafika}
Az alábbiakban a grafikus alrendszer néhány jellemzõje, a számítógépi grafika teljesítmény és memória igénye, valamint az erõforrás használat optimalizálásához használható, grafikai algoritmusok és adatstruktúrák kerülnek bemutatásra.

\Section{Számítógépi grafika erõforrás igényei}
A számítógépi grafika egy komplex területe az információs technológiáknak. Az alábbiakban láthatjuk részletezve, hogy milyen elvárásokkal néz szembe egy alkalmazás, ami három-dimenziós alakzatokat jelenít meg \textbf{valós} idõben.
\SubSection{Számítási igény}
Ismert, hogy annak érdekében, hogy az ember mozgóképnek érzékeljen, folyamatos sorban prezentált képeket, legalább 6 különbözõ képnek kell megjelennie másodpercenként. Ahhoz pedig, hogy a mozgóképet úgy érzékeljük, mintha az nem is képek sorozata lenne, hanem egy valójában egybefüggõ animáció, másodpercenként legalább 24 kép megjelenítésére van szükség. Általában ez a legalsó korlátja azoknak az alkalmazásoknak, melyek valósidejû grafikai szimulációkat futtatnak, de sok esetben ennél jóval több 30, vagy akár 60 is lehet a szükséges képek száma másodpercenként. Ennek oka, hogy a grafikai alkalmazások feladata jellemzõen nem kizárólag a képek megjelenítése. Esetünkben is szeretnénk ha az alkalmazás \textit{interaktív} lenne, tehát szkripteket futtatna, és azok által felhasználói beavatkozást tenne lehetõvé különbözõ bemeneti eszközökön keresztül. Ezen kívül még rengeteg feladata lehet egy ilyen alkalmazásnak, mint például a fizikai szimulációkhoz kapcsolódó számolások elvégzése, vagy a hang effektek létrehozása.

Láthatjuk tehát, hogy annak érdekében, hogy az alkalmazásunk megfelelõ vizuális és \textit{reszponzivitási} élményt nyújtson, nem kezelhetjük könnyelmûen az egy konkrét kép létrehozására allokált idõt és egyéb erõforrásokat. Ha azt szeretnénk, hogy legalább 30 legyen a másodpercenként prezentált képek száma, egy alkalmazás iteráció (a rajzfelület törlésétõl az új kép megjelenítéséig eltelt idõ) nem tarthat tovább, mint $\frac{1}{30}$ másodperc.

\SubSection{Memória igény}
\label{SubSection:glmemory}
A megfelelõ vizuális élmény szolgáltatása érdekében, jellemzõen óriási adatstruktúrákra van szükség. A két alapvetõ megjelenítési entitás a geometriai objektumok, és a textúrák, amik a geometria valósághû megjelenítéséért felelõsek. Nézzük meg, hogy mik is valójában a memória igényei ezeknek az objektumoknak.

A geometriai objektumok jellemzõen csúcspontokból, és ahhoz kapcsolódó kiegészítõ információkból épülnek fel. Legyen most $N$ a csúcspontok száma egy tetszõleges objektumban.

Egy csúcspont a következõ információkat tartalmazza általában, melyeknek szükséges memóriát allokálni:

\begin{itemize}
\item A csúcs helyzete a három-dimenziós térben. Ez leírható egy három komponensû vektorral, melynek komponensei lebegõpontos számok. A C++ környezet támogatja a lebegõpontos számok 32 biten történõ ábrázolását a \textit{float} adattípussal \cite{cpp_fundamental_types}. Ezzel összhangban van a használt grafikus környezet, az \textit{OpenGL} méret kiosztása is \cite{ogl_fundamental_types}. Egy csúcs térbeli helyzetének leírásához szükséges tárhely tehát: $3*32=96$ bit.
\item A csúcshoz rendelt textúra koordináta. Ez egy két-dimenziós pozíció érték, ami azt adja meg, hogy az adott csúcshoz, a textúra mely pontját kell rendelni az objektum megjelenítése során. Ez tárolható egy két komponensû, lebegõpontos szám típusú vektorban, tehát a helyigény: $2*32=64$ bit.
\item A csúcshoz rendelt normális, binormális és tangens vektor. Ezeknek a vektoroknak az objektum megvilágítási számításaiban van szerepe. Fontos, hogy a három vektor közül egyet elégséges tárolni, hiszen a másik kettõ minden esetben számítható belõle. Azonban a valósidejû kiszámítása ezeknek a vektoroknak értékes idõt vehet el a rajzolási folyamatok közben, tehát mérlegelni kell, hogy a memória használatot vagy a számítási idõt helyezzük elõtérbe. Ebben az esetben tároljuk a vektorok mindegyikét, tehát a helyigény: $3*3*32=288$ bit.
\end{itemize}

Nem a csúcspontra hanem a geometriára jellemzõ attribútum az \textit{oldalak} száma. Eddig a geometriai objektum csúcspontjait definiáltuk, ezek azonban nem elégségesek a geometria rekonstruálására, hiszen a csúcspontok tetszõleges módon köthetõek össze. Szükségünk van még arra az információra, hogy mely csúcsok alkotnak egy-egy \textit{sokszöget}, illetve a számítógépi grafikában jellemzõ \textit{háromszögeket}.

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/monkeyheadtrian.eps, width=8cm, height=6cm}
\caption{Geometria 507 csúccsal és 968 oldallal}
\label{fig:monkeyhead}
\end{figure}

Ez az információ megadható lenne a csúcspontok leírásával, azonban ez nem hatékony, hiszen egy összefüggõ alakzatban több sokszög osztozik egy-egy csúcson. Ennek kiküszöbölésére, a csúcspontokat nem közvetlenül használjuk a sokszögek definiálására, hanem indexeken keresztül. Így tehát egy sokszög leírására egész számokat használunk, amelyek a csúcspontok halmazát indexeli. A \myref{fig:indexedgraph} ábrán látható, hogy a \myref{fig:monkeyhead} ábra geometriája, különbözõ degeneratív állapotokban (az eredeti geometria csúcspontjainak csökkentése bizonyos arányban) hány csúcsot illetve háromszöget tartalmaz. A két grafikon megmutatja a különbözõ állapotokban a tárhelyigény alakulását az indexek használatával (kék grafikon) és az indexek használata nélkül (piros grafikon).

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/meshindexedgraph.eps, width=15cm, height=9cm}
\caption{Geometria tárhely igénye indexelt és nem indexelt csúcsokkal}
\label{fig:indexedgraph}
\end{figure}

Az indexek memóriaigénye függ attól, hogy milyen sokszögekbõl épül fel a geometria, azonban a legtöbb esetben a grafikus alkalmazások preferált formátuma a háromszögekbõl felépített objektumok, ezért ezzel számolunk: Egy elõjel nélküli 32 bites egész szám elégséges lesz a csúcspontok indexeléséhez, amit a C++ környezetben az \textit{unsigned int}, OpenGL környezetben pedig a \textit{GLuint} biztosít \cite{cpp_fundamental_types}\cite{ogl_fundamental_types}. Így tehát a $F*3*32$ bit következik helyigénynek, ahhol $F$ az oldalak száma.

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/factory.eps, width=3.5cm, height=7cm}
\caption{Geometria 123550 csúccsal és 237252 oldallal}
\label{fig:factory}
\end{figure}

Egy geometriai objektum memóriaigénye ezek alapján tehát: $N*(96+64+288)+F*96=N*448+F*96$ bit.

Az ábrán (\myref{fig:monkeyhead}) látható aránylag egyszerû objektumnak 507 csúcsa és 968 oldala van. Ha a fent leírt formátumban tároljuk a memóriában, akkor az objektum helyigénye: $507*448+968*96=320064$ bit, ami $320064/8=40008$ bájt azaz $40$ kilobájt.

Egy bonyolultabb objektum (\myref{fig:factory}) - mely 123550 csúccsal és 237252 oldallal rendelkezik - helyigénye a következõképpen alakul: $123550*448+237252*96=$ bit, ami $78126592/8=9765824$ bájt azaz $9765,8$ kilobájt.

Az \textit{ogl\_graphics/ogl\_asset} útvonalon található az \textit{ogl\_mesh} osztály megvalósítása, aminek felelõssége a tárgyalt adatok tárolása:

\begin{cpp}
private:
  std::vector< glm::vec3 > m_positions;
  std::vector< glm::vec2 > m_uvs;
  std::vector< glm::vec3 > m_normals;
  std::vector< glm::vec3 > m_tangents;
  std::vector< glm::vec3 > m_bitangents;
  std::vector< std::vector< GLuint > > m_indices;
  std::vector< GLenum > m_topologies;
...
\end{cpp}

Az \textit{std::vector} standard C++ típus jellemzõje, hogy a tárolt objektumokat folytonos memóriaterületen helyezi el. Ez fontos tulajdonság az OpenGL szempontjából, hiszen a grafikus memóriába történõ feltöltés csak folytonos memóriaterületrõl lehetséges. 

A számolásokat háromszög alakú oldalakat feltételezve végeztük el, annak érdekében azonban, hogy megtudjunk jeleníteni más formában tárolt geometriai objektumokat, vagy objektum-részeket, tároljuk az egyes geometria részekhez tartozó topológiákat is. Ezek lehetnek pontok, vonalak, háromszögek vagy egyéb sokszögek.

Jellemzõen a grafikus környezetek a textúrákat nem tömörített formában tudják feldolgozni. Ez azt jelenti, hogy minden egyes \textit{texelhez} (a textúra egy pontja) tartozó adatot el kell tudnunk tárolni. Egy általános esetben a textúrák a \textit{RGBA8} formátumban kerülnek felhasználásra. Ez azt jelenti, hogy a GPU memóriában minden texelt $4*8=32$ bit ír le, ahol a három színcsatornának 8-8 bit, valamint az \textit{alpha} (átlátszóság) csatornának is 8 bit jut.

Például a megvalósított textúra objektum esetén (ogl\_graphics/ogl\_asset texture osztály), a textúra adat videómemóriába történõ feltöltése a következõképpen történik:

\begin{cpp}
glTexImage2D( GL_TEXTURE_2D, 0, GL_RGBA, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, &m_data[ 0 ] );
\end{cpp}

A \textit{GL\_RGBA} érték határozza meg, elsõ esetben a feltöltendõ adat formátumát, második esetben pedig a feltöltés utáni "belsõ" formátumot. Ennél a lépésnél a \textit{m\_data} változó már tartalmazza a dekódolt, kitömörített textúra adatát.

A textúrák mérete rendkívül széles skálán változhat, tekintsünk most egy 512 texel méretû, négyzet alakú textúrát. Ilyen jellegû textúra gyakori lehet ismétlõdõ textúrázásnál, falak vagy természetes talajok megjelenítése esetén (\myref{fig:landscape} ábra). Ekkor a textúra mérete egyértelmûen adódik: A texelek száma $512^2=262144$, a tároláshoz szükséges méret pedig $1048,5$ kilobájt.

Láthatjuk, hogy már egyetlen összetettebb alakzatnak is néhány megabájt, míg egy kifejezetten egyszerû és kisméretû textúrának is több, mint 1 megabájt lehet a memória igénye. Ilyen entitásokból azonban több száz vagy akár több ezer található egy-egy grafikai szimulációban vagy jelenetben. Egy átlagos videókártyának a memóriája 1-2 gigabájt nagyságú, amit azonban értelemszerûen nem kizárólagosan használ az alkalmazás, az számos futó processz között lehet megosztva. Ezek után könnyen belátható, hogy szükséges a memóriát foglaló objektumok szigorú felügyelete, valamint a precíz pufferelési technikák használata.

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/landscape.eps, width=12cm, height=6.75cm}
\caption{Ismétlõdõ textúra a talaj színezésére \cite{texture_picture}}
\label{fig:landscape}
\end{figure}

\Section{Optimalizációs lehetõségek}
\label{section:optimalize}
Az elõzõ részben láthattuk, hogy milyen számítási és memória nehézségei vannak egy grafikus alkalmazásnak. A következõkben ezekre a problémákra keresünk megoldásokat különbözõ adatstruktúrák és algoritmusok segítségével.
\SubSection{Oktális fák}
Az \textit{oktális fák} olyan fa gráfok, melyekre teljesül, hogy minden belsõ csúcsnak \textbf{pontosan} 8 gyermeke van (innen az "oktális" elnevezés). Az oktális fák, a kvadrális fák megfelelõje a három-dimenziós térben. A struktúra attól válig különlegessé, hogy az egyes csúcspontokhoz valamilyen módszer szerint térrészeket rendelünk. Általában minden csúcsponthoz egy kocka alakú térrész van rendelve, úgy, hogy a mindenkori gyermekekhez azon nyolc egyenlõ méretû térrész van rendelve, amelyek összege egyenlõ a szülõhöz rendelt térrésszel.

Az oktális fák csoportosíthatóak a tér felosztás jellege szerint:

\begin{itemize}
\item A pont alapú felosztás során, a fa minden csúcsa egy pontot reprezentál a térben, ami a felosztási pontot jelenti. Mivel csak a felosztás pontja van tárolva a csúcsokban, a csúcsokhoz rendelt térrész mérete nem meghatározott. Ebbõl az következik, hogy a fa gyökér csúcsához a végtelen tér van rendelve. Ennek elõnye, hogy elõre nem ismert méretû térrész is kezelhetõ benne, hátránya viszont, hogy csak diszkrét pontok adhatóak hozzá a fához. Ez esetünkben probléma lesz, hiszen általában kiterjedt geometriai objektumokat (illetve azok egy térbeli közelítését) szeretnénk majd tárolni a fában.
\item A tér alapú felosztás során, a fa minden csúcsához a térrész közepét rendeljük. Ennek hátránya, hogy elõre ismernünk kell egy véges térrész paramétereit, amit a fa gyökér csúcsához rendelünk. Elõnye pedig, hogy így tárolhatunk véges kiterjedésû geometriákat a struktúrában.
\end{itemize}

Csoportosíthatunk továbbá a dinamika szempontjából:

\begin{itemize}
\item Statikus az oktális fa, ha azt egyszer építjük fel, egy elõre meghatározott geometria (vagy pont) halmazból és nem változik a szerkezete az élettartama során. Ennek elõnye, hogy nem szükséges kezelni azokat az eseteket, melyek során a fában tárolt objektumok valamely fizikai paramétere (kiterjedése, pozíciója vagy orientációja) megváltozhat. Ez hasznos lehet akkor, ha van egy elõre ismert objektum halmaz, melynek elemeirõl tudjuk, hogy nem változtathatóak meg a paramétereik. Egy grafikai szimulációban, például egy videójátékban ilyenek lehetnek a hátteret alkotó geometriák, mint házak, nem animált fák stb.
\item Dinamikusnak nevezzük az oktális fát, ha az abban tárolt objektumok fizikai paraméterei megváltozhatnak, és ezzel a fa belsõ struktúrája is módosításra kerülhet. Hátránya, hogy szükséges a program szintjén kezelni ezeket az eseteket, ami akkor is okozhat teljesítménybeli különbséget a statikus fával szemben, ha a fa struktúrája végül soha nem változik meg. Elõnye természetesen, hogy a benne tárolt objektumok fizikai paraméterei tetszõlegesen változtathatóak.
\end{itemize}

A megvalósított oktális fa (\textit{core/octree}) egy tér alapú, dinamikus fa, amelynek a gyökér eleméhez egy véges, kocka alakú térrészt rendelünk. A felosztás során a térrész középpontját tekintjük a gyermek térrészek közös pontjának, így nyolc egyenlõ, szintén kocka alakú térrészt kapunk. A további felosztások pedig rekurzívan történnek a gyermek elemekre.

Az implementáció fõ struktúrája az \textit{octree\_node} osztály-sablon, aminek típus paramétere egy \textit{tértípus}. Azért elõnyös ez az absztrakció, mert tetszõleges struktúrában, tetszõleges módon definiált objektumokkal válik használhatóvá az oktális fa. Ennek a típusnak a következõ funkciókat kell megvalósítania:

\begin{itemize}
\item \textit{containedin(box)} igazzal tér vissza ha a tértípus adott példányát magába foglalja a megadott térrész, hamisat egyébként. A fába történõ beillesztéshez szükséges, hiszen az eljárás során azt vizsgáljuk, hogy a fának melyik az a legkisebb csúcsa, ami magába foglalja a térrészt.
\item \textit{equals(volume)} paraméterül kap egy másik tértípus példányt, és igazzal kell visszatérnie ha azzal megegyezik, hamissal egyébként. A fában történõ kereséshez szükséges, hiszen valamilyen módon el kell tudnunk dönteni, hogy a keresett példányt találtuk meg a fában vagy nem.
\item \textit{changed} igazzal tér vissza, ha megváltozott a példány valamely fizikai paramétere. A fa dinamikus funkciójához szükséges, azokat a példányok, melyek azt jelzik, hogy változás történt a helyzetükben, esetlegesen újra el kell helyezni a fában.
\end{itemize}

\subsubsection{Beillesztés oktális fába}

Tekintsünk egy statikus oktális fát, tér alapú, kocka felosztással. Adott tehát egy $R_0$ \textit{tengelyekhez igazított} kocka (a kocka élei párhuzamosak illetve merõlegesek az $x,y,z$ tengelyekre) és annak geometriai középpontja $O_0$, ezek fogják jelenteni a fa gyökér elemét. Adott továbbá egy $W_0$ tetszõleges térbeli alakzat $V={v_0,v_1,\ldots,v_n}$ csúccsal és $F={V^{n_0}_0, V^{n_1}_1,\ldots,V^{n_y}_f}$ oldallal, úgy, hogy $N={n_0,n_1,\ldots,n_y}$ a különbözõ számú csúccsal rendelkezõ oldalak csúcsszáma, a $V^{n_i}_j$ pedig az alakzat $j$-edik oldala, $n_i$ csúccsal.

A beillesztés rekurzív algoritmusa a következõ:

\begin{enumerate}
\item Ha a fa aktuális csúcsához tartozó térrész $R_x$, magába foglalja a $W_0$ alakzatot, akkor lépjünk a következõ lépésre, egyébként visszatér az algoritmus \textit{hamis} értékkel. A térrész magába foglalja az alakzatot akkor, ha teljesül, hogy az $R^{min}_x$ csúcs kisebb, az $R^{max}_x$ pedig nagyobb minden, a $W_0$ alakzathoz tartozó $v_i (i=0,1,\ldots,n)$ csúcsnál. Az $R^{min}_x$ és $R^{max}_x$ pont, a facsúcshoz tartozó kocka pontjai közül a legkisebb illetve legnagyobb.
\item Vegyük sorra az aktuális csúcs gyermekeit, és hívjuk az eljárást rekurzívan rájuk. Ha \textit{igaz} értékkel tér vissza az adott gyermek eljárása akkor térjünk vissza \textit{igaz} értékkel. Ha egyik gyermek sem tért vissza \textit{igaz} értékkel, akkor tároljuk az aktuális csúcs listáján a $W_0$ alakzatot és térjünk vissza \textit{igaz} értékkel.
\end{enumerate}

Az így kialakított algoritmus eredménye az lesz, hogy a megadott $W_0$ alakzatot azon facsúcs fogja tárolni, amely térrésze magába foglalja az alakzatot, és kiterjedése a legkisebb, azon térrészek közül, amelyek szintén magukba foglalják az alakzatot.

Az algoritmus implementációja látható a \textit{octree\_node} osztály, \textit{addvolume} függvényben. Az implementáció egy érdekessége, hogy a beillesztés kezdetekor nem biztos, hogy létezik az a facsúcs, amibe be fogjuk illeszteni a megadott elemet. Az elsõ lépésben végigiterálunk a kezdõcsúcs gyermekein:

\begin{cpp}
...
bool initch = false;
for (uint8_t i = 0; i < 8; ++i) {
  if (mchildren[i] == nullptr) {
    initch = true;
  } else if (mchildren[i]->addvolume(vol)) {				
    return true;
  }
}
...
\end{cpp}

Azt vizsgáljuk, hogy van-e olyan gyermeke az adott csúcsnak, ami még nem lett létrehozva (\textit{nullptr} az értéke a gyermekre mutató változónak), és ha van ilyen, beállítunk egy jelzõ értéket (\textit{initch}). Eközben a már létrehozott gyermekekre megpróbáljuk a beillesztést, hiszen ha valamelyikük magába foglalja a megadott térrészt, akkor nem szükséges új gyermek csúcsokat inicializálni.

Ha egyik gyermek sem tudta befogadni a térrészt, akkor azt vizsgáljuk meg, hogy a még nem létrehozottak közül van-e olyan, ami \textbf{betudná-e}, ha létre \textbf{lenne} hozva. Ezt úgy tesszük, hogy létrehozzuk azokat a struktúrákat amik leírnák az aktuálisan vizsgált gyermek térrészét, ha az létre lenne hozva, és megnézzük, hogy abba bele tudna-e kerülni a megadott elem:

\begin{cpp}
...
aabb tmpbox;
for (uint8_t i = 0; i < 8; ++i) {
  if( mchildren[ i ] ) continue;

  std::bitset<3> bidx(i);
  vec3 tmpmid = {
    (bidx.test(0) ? 1 : -1) * mbox.size().x / 2,
    (bidx.test(2) ? -1 : 1) * mbox.size().y / 2,
    (bidx.test(1) ? -1 : +1) * mbox.size().z / 2
  };

  tmpbox.mid(tmpmid);
  glm::vec3 tmpsize( mbox.size().x / 2, mbox.size().y / 2, mbox.size().z / 2 );
  tmpbox.size( tmpsize );
  
  if (vol.containedin(tmpbox)) {
    poctree_node<volume_t> nn = new octree_node(tmpbox, mmaxvolume);
    mchildren[i] = nn;
    return nn->addvolume(vol);
  }
}
...
\end{cpp}

A \textit{tmpbox} tárolja azt a térrészt, ami az adott gyermekhez tartozna. Ha ez az ideiglenesen létrehozott struktúra megfelelõnek bizonyul, akkor valóban létrehozásra kerül a gyermek ezzel a térrésszel, és ott folytatódik a rekurzív beillesztés.

Az algoritmus szempontjából némi rugalmasságot jelent, hogy a fa bármely csúcsánál elkezdõdhet a rekurzió. Például ha valamilyen speciális esetben, további információk állnak rendelkezésünkre azt illetõen, hogy a beilleszteni kívánt objektum mely térrészekben helyezkedik el, akkor elegendõ lehet valamely közvetett vagy közvetlen gyermektõl kezdeni az algoritmust, a gyökér elem helyett.

Az ilyen módon felépített struktúra hatékonyan használható különbözõ térbeli lekérdezésekhez. Ilyen lesz például a láthatósági lekérdezés, amit a \myref{section:visibilityquery} részben tárgyalunk. Fontos alkalmazási területe továbbá az oktális fának, a fizikai szimulációk során alkalmazott \textit{ütközési vizsgálatok} optimalizációja. Erre azon fontos tulajdonsága teszi alkalmassá a fát, hogy elõre ismert azon objektumok halmaza (egy facsúcs és a csúcs gyermekeinek listájában tárolt objektumok), amik között elõfordulhat ütközés, ezáltal jelentõsen csökkentve a vizsgálatok szükséges számát.

\subsubsection{Dinamikus oktális fa}

A dinamikus oktális fa képes követni a benne tárolt objektumok helyzetét, és szükség esetén újrastruktúrálni önmagát. A statikus változattal ellentétben, a fa felépítése és az objektumok, csúcsokhoz történõ hozzárendelése nem egyszer történik meg hanem szükség szerint bármennyiszer végbemehet. A fába történõ beillesztést nem befolyásolja a fa dinamikus jellege, csupán kiegészítjük a struktúrát egy \textit{frissítés} eljárással, ami azért lesz felelõs, hogy a megváltozott objektumokat új csúcshoz rendelje, amennyiben az szükséges.

A frissítés algoritmusa a következõ:

\begin{enumerate}
\item Ha van még feldolgozatlan elem a fa aktuális csúcsához rendelt objektumok között, akkor vegyük a következõt. Ha nincs, haladjunk a \myref{laststep} lépésre.
\item Ellenõrizzük, hogy az aktuális elemmel történt-e változás. Ehhez, az objektumnak alkalmasnak kell lennie arra, hogy információt szolgáltasson a változás tényérõl. Ha az adott objektum azt jelzi, hogy változás történt az elhelyezkedését illetõen, akkor ellenõrizzük, hogy a csúcshoz rendelt térrész továbbra is magába foglalja-e az objektumot. Ha igen, akkor haladjunk az elsõ lépésre.
\item Ha nem, akkor eltávolítjuk a csúcs listájáról az objektumot, és meghívjuk a hagyományos beillesztési eljárást rá, annak érdekében, hogy újra a megfelelõ csúcs listájára kerüljön. Láthattuk, hogy a beillesztési eljárás lehetõvé teszi, hogy a bejárást tetszõleges csúcsnál kezdeményezzük. Ebben az esetben különösen hasznosnak bizonyulhat ez a lehetõség, hiszen egy valós esetben az objektumok elmozdulása igen gyakori lehet, ami gyakori újraillesztést eredményezhet. Ehhez azonban szükség van valamilyen, az alkalmazási területre specifikus információra (például ha tudjuk elõre, hogy csak nagyon kis mértékben változik mindig az objektumok helyzete, akkor kezdhetjük az újraillesztést az eredeti csúcs szülõ csúcsánál).
\item\label{laststep} Ezt a lépést egyszerûen az eljárás meghívása jelenti, rekurzívan az adott csúcs, gyermek csúcsaira, ezzel biztosítva, hogy a teljes fa (\textit{alfa}) frissítésre kerül.
\end{enumerate}

Az algoritmust megvalósítja az \textit{octree\_node} osztály \textit{update} funkciója. Az újraillesztés kezdõcsúcsa megadható paraméterben a funkciónak (\textit{treatasroot}). Egyébiránt a megvalósítás teljes mértékben követi az általános leírást.

\subsection{Láthatósági lekérdezés oktális fával}
\label{section:visibilityquery}
\subsubsection{Nézõpont struktúrák}
A számítógépi grafika egy lényeges struktúrája a nézõpontot, illetve a megjelenített virtuális teret \textit{szemlélõ} entitás, nézeti paramétereit reprezentáló objektum. Általános esetben ezeket az objektumokat kamerának szokás nevezni. Elõfordulhat, hogy az emberi szem tulajdonságaival vonunk párhuzamot a struktúra leírásakor, azonban vannak olyan nézeti típusok (ortogonális projekció), melyek nem magyarázhatóak ebben a megközelítésben.

A kamera struktúra azért felelõs, hogy egy matematikailag jól definiált módon írja le, hogy a virtuális térnek melyik az a része, amit a grafikus alrendszernek meg kell jelenítenie. Ennek érdekében a struktúrába a következõ adattagokat vezetjük be:

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/perspective.eps, width=7.5cm, height=4.2cm}
\caption{A perspektivikus projekció paraméterei \cite{perspective_picture}}
\label{fig:perspective}
\end{figure}

\begin{itemize}
\item A kamera legfontosabb jellemzõje, a projekció típusa. Ez határozza meg, hogy milyen további adatokra van szükség a \textit{nézeti transzformáció} leírásához. A projekció típusa lehet \textbf{ortogonális} és \textbf{perspektivikus}.
\end{itemize}

Az ortogonális projekció egyedi paraméterei:
\begin{itemize}
\item Az ortogonális projekció esetén direkt módon kell megadnunk a kamera alakzat paramétereit. Az alakzatot a \textit{minimum csúcs} és a \textit{maximum csúcs} definiálja. A minimum csúcs a $P_1=(L, B, -N)$, a maximum csúcs pedig a $P_2=(R, T, -F)$ pontként áll elõ. Az $L,B,R,T$ paramétereket szabadon definiáljuk, az $N,F$ paraméterek pedig a közeli (\textbf{N}ear) és távoli (\textbf{F}ar) vágósík távolságokból adódnak. Az \myref{fig:ortho} ábra címkéi alapján: $P_1=(xLeft, yBottom, -zNear)$ és $P_2=(xRight, yTop, -zFar)$.
\end{itemize}

A perspektivikus projekció egyedi paraméterei:
\begin{itemize}
\item A nézõpont, horizontális fél-nyílásszöge. Megadja a vágósíkok közepén, és a nézõponton átmenõ egyenes, valamint a nézõponton és a közeli (vagy távoli) vágósík, valamely függõleges oldalának közepén átmenõ egyenes által bezárt szöget. Az \myref{fig:perspective} ábrán, az $\overline{AB}$ és $\overline{AC}$ szakaszok által bezárt szög.
\item Képernyõ méret aránya. A vetítési felület szélességének és magasságának aránya. Az \myref{fig:frustum} ábrán, a \textit{width} és \textit{height} aránya. Az ábrán a vetítési felület és a közeli vágósík egybe esik ($N=0$), de ez általában nem így van.
\end{itemize}

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/frustum.eps, width=10.05cm, height=7.05cm}
\caption{A perspektivikus projekció paraméterei \cite{ogl_guide}}
\label{fig:frustum}
\end{figure}

A két projekció típus közös paraméterei:
\begin{itemize}
\item Közeli vágósík távolsága. Megadja a nézõpont (ortogonális projekció esetén \textit{"nézõsík"}) és a közeli vágósík távolságát. Az \myref{fig:perspective} ábrán a \textit{z=near} távolság. Azon pontok, melyek ennél közelebb vannak a nézõponthoz (\textit{eye}), nem kerülnek megjelenítésre.
\item Távoli vágósík távolsága. Megadja a nézõpont és a távoli vágósík távolságát. Az \myref{fig:perspective} ábrán a \textit{z} távolság. Azon pontok, melyek ennél távolabb esnek a nézõponttól, nem kerülnek megjelenítésre.
\end{itemize}

Ortogonális projekció esetén, a három-dimenziós térbõl, kettõ-dimenziós felületre történõ vetítés párhuzamos egyenesekkel történik. A leírt paraméterek egy "dobozt" határoznak meg, melyet úgy transzformálunk, hogy a középpontja, a kamera koordináta-rendszerének origójára essen. A transzformáció után, egység kockává skálázzuk az alakzatot, úgy, hogy a minimum pontja a $(-1,-1,-1)$ pontra, a maximum pontja pedig a $(1,1,1)$ pontra essen \cite{wiki_ortho}. A projekció ezen fajtája szögtartó, megõrzi az egyenesek párhuzamosságát, a szakaszok méretarányait valamint a területek arányát. \cite{math_ortho}. Ezen jellemzõk lehetõvé teszik, hogy pontos méréseket végezzünk a három-dimenziós tér vetületében, valamint, hogy pixel-helyesen jelenítsünk meg, például grafikus felhasználói felület elemeit (gombok, címkék). Az ortogonális projekció mátrix alakja:

\[
\begin{bmatrix}
\frac{2}{W} & 0           & 0              & 0\\
0           & \frac{2}{H} & 0              & 0\\
0           & 0           & -\frac{2}{F-N} & -\frac{F+N}{F-N}\\
0           & 0           & 0              & 1
\end{bmatrix}
\]

Perspektivikus projekció esetén a vetítés összetartó egyenesekkel történik. Az egyenesek metszéspontja a nézõpont (\textit{fókuszpont}). A vetítés ekkor nem távolság, párhuzamosság vagy szögtartó. A valósághû megjelenítés érdekében - ahogy a való életben is tapasztaljuk - a távolabbi objektumok kisebbnek, a közelebbiek pedig nagyobbnak fognak tûnni. A paraméterek egy \textbf{gúlát} határoznak meg, a megjelenített térrész pedig - a közeli vágósíknál történõ vágás után - egy csonka gúla lesz. A perspektivikus projekció mátrix alakja:

\[
\begin{bmatrix}
\frac{2*N}{W} & 0             & 0                & 0\\
0             & \frac{2*N}{H} & 0                & 0\\
0             & 0             & -\frac{F+N}{F-N} & \frac{2*F*N}{F-N}\\
0             & 0             & -1               & 0
\end{bmatrix}
\]

A kamera struktúrákat az úgynevezett \textit{camera\_node} valósítja meg, ami az \textit{ogl\_graphics/ogl\_scene\_node} útvonalon található meg. A tárgyalt paraméterek komponens attribútumokként jelennek meg az osztályban:

\begin{cpp}
component_attribute( m_projection_mode, std::string );
...
component_attribute( m_bottom, float );
component_attribute( m_top, float );
component_attribute( m_near_clip, float );
component_attribute( m_far_clip, float );
...
\end{cpp}

A két különbözõ típusú (ortogonális és perspektivikus) struktúrának nincs külön osztálya, a \textit{projection\_mode} paraméter dönti el, hogy hogyan kerül kiszámításra a projekciós transzformáció mátrixa:

\begin{cpp}
if( m_projection_mode.get_value() == "perspective" ) {
  m_projection_matrix = glm::perspective< float >( 
    m_field_of_view, m_aspect_ratio, m_near_clip, m_far_clip );
...
} else {
  m_projection_matrix = glm::ortho< float >( 
    m_left, m_right, m_bottom, m_top, m_near_clip, m_far_clip );
}
\end{cpp}

\subsubsection{A nézõpont struktúrák elhelyezése az oktális fában}
Láthattuk tehát a korábbi részekben, hogy hogyan tárolhatunk objektumokat egy oktális fában valamint, hogy milyen struktúrákkal reprezentáljuk a virtuális teret figyelõ objektumot. A következõkben azt vizsgáljuk meg, hogy hogyan alkalmazható a két adatstruktúra együttesen, a láthatósági vizsgálat megvalósítására.

A láthatósági vizsgálatok jelentõsségét általánosan igazolhatjuk a korábban bemutatott adatokkal, melyek szerint egy-egy geometriai objektum és az azokhoz tartozó textúrák megjelenítése egy teljesítmény-költséges folyamat. Természetesen a cél az, hogy minél több processzor idõt és memóriát spóroljunk. A legtöbbet pedig azokon az objektumokon spórolhatunk, amiket egyáltalán nem jelenítünk meg. Ehhez az kell, hogy a rajzolási folyamat minél korábbi szakaszában és minél kisebb költséggel meghatározhassuk, hogy egy objektum látható-e vagy sem.

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/ortho.eps, width=9.6cm, height=5.6cm}
\caption{Az ortogonális projekció paraméterei \cite{ortho_picture}}
\label{fig:ortho}
\end{figure}

Az elsõ megoldást a láthatósági problémára általában maga a grafikus környezet nyújtja. A grafikus feldolgozó eszközök a képalkotási folyamat során "eldobják" azokat a geometria részeket, amik nem fognak látszódni a képernyõn, a vágás során. Ahhoz azonban, hogy a grafikus környezet meg tudja határozni egy-egy ponthalmaz láthatóságát, már át kellett esniük a teljes transzformációs láncon, ami már önmagában jelentõs számú mûveletet jelent.

A következõ lépésben bevezetünk egy új struktúrát. Tudjuk, hogy egy geometriai objektum akkor fog látszódni ha valamely pontja benne van a kamera struktúra által meghatározott térrészben (csonka gúla perspektivikus, és téglatest ortogonális projekció esetén). Láttuk azonban azt is, hogy egy-egy ilyen objektum állhat több száz, vagy akár több tízezer pontból is, így a pontonkénti ellenõrzés nem lenne hatékony. Az új struktúra tehát, legyen egy \textit{közelítése} az eredeti objektumnak, a következõ képpen: 
\begin{itemize}
\item Legyenek az $A,B,C,D,E,F,G,H$ pontok egy téglatest csúcsai,
\item $x_{min},y_{min},z_{min},x_{max},y_{max},z_{max}$ legyenek valós számok és
\item $V_x,V_y,V_z$ a közelíteni kívánt geometria összes csúcsának x, y és z koordinátájának halmazai
\end{itemize}
\begin{alignat*}{3}
V_x &= \{v_{1x},v_{2x},\ldots,v_{nx}\}\\
V_y &= \{v_{1y},v_{2y},\ldots,v_{ny}\}\\
V_z &= \{v_{1z},v_{2z},\ldots,v_{nz}\}
\end{alignat*}
Legyen
\begin{alignat*}{4}
x_{min} &= min(V_x)\\
y_{min} &= min(V_y)\\
z_{min} &= min(V_z)\\
x_{max} &= max(V_x)\\
y_{max} &= max(V_y)\\
z_{max} &= max(V_z)
\end{alignat*}
valamint
\begin{alignat*}{5}
A &= (x_{min},y_{max},z_{min})\\
B &= (x_{max},y_{max},z_{min})\\
C &= (x_{min},y_{max},z_{max})\\
D &= (x_{max},y_{max},z_{max})\\
E &= (x_{min},y_{min},z_{min})\\
F &= (x_{max},y_{min},z_{min})\\
G &= (x_{min},y_{min},z_{max})\\
H &= (x_{max},y_{min},z_{max})
\end{alignat*}
 
 Az így definiált téglatest \textit{"magába foglalja"} a közelíteni kívánt alakzatot. A közelítés segítségével megtehetjük azt az optimalizációs lépést, hogy az alakzat minden csúcsa helyett, csak a téglatest négy csúcsát vizsgáljuk. Természetesen a láthatósági vizsgálat pontossága így degradálódik, azonban a legjobb esetben a "láthatatlanságot" megállapíthatjuk már a négy pont ellenõrzésével is.
 
 Ezen struktúra kiszámítását láthatjuk a geometria tartalom objektumok betöltése során is. Az \textit{ogl\_graphics/ogl\_asset} útvonalon, a \textit{mesh::load} funkció a geometriai alakzatban definiált pontokat tölti be a már látott tároló változókba, miközben számontartja, hogy melyik a "legkisebb" illetve a "legnagyobb" a pontok között.
 
 A közelítõ téglatesttel elértük, hogy némely esetben csupán néhány mûvelet szükséges a láthatóság kizárásához. A végsõ lépés a láthatósági vizsgálat optimalizációjában, az oktális fa használata.
 
 Tudjuk a korábban leírtak alapján, hogy a kamera struktúrákat egy-egy véges, zárt geometriai alakzat reprezentálja. Ennek elõnye, hogy bármely más kiterjedt alakzathoz hasonlóan, ezeket is elhelyezhetjük az oktális fában. Jelen esetben azonban nem a kamera tárolása lesz a cél, hanem azon legkisebb térrész meghatározása, amely tartalmazza a kamera alakzat minden pontját.
 
 Ehhez elõször meg kell határoznunk a kamera struktúra pontjait, a kamera paraméterei alapján. A már említett \textit{camera\_node::\_update\_to\_projection\_mode} funkcióban történik a kamera alappontjainak kiszámítása is. Legyen $F_y$ a nézõpont horizontális nyílásszöge, $W_{near}, W_{far}, H_{near}, H_{far}$ rendre a közeli illetve távoli vágósík szélessége illetve magassága, valamint $R$ a vágósíkok oldalaránya. Ekkor teljesülnek a következõ összefüggések:
 
 \begin{alignat*}{4}
 &t := 2 * tan( F_y / 2)\\\\
 &W_{near} = t * D_{near}\\
 &W_{far} = t * D_{far}\\
 &H_{near} = W_{near} * R\\
 &H_{far} = W_{far} * R
 \end{alignat*}
 
 Ezek alapján a struktúra pontjainak koordinátái egyértelmûen adódnak, ha a fókusz pontot tekintjük az origónak. Az utolsó lépés az oktális fával történõ "egyeztetés" elõtt, hogy transzformáljuk a pontokat a kamera aktuális helyzetének megfelelõen.
 
 Végül az oktális fa szokásos mûködése alapján, bejárjuk a fa csúcsait, és mindaddig haladunk rekurzívan a csúcsokhoz tartozó térrészeken, amíg meg nem találjuk azt a csúcsot, amely tartalmazza a meghatározott pontok mindegyikét és a lehetõ legkisebb az alfában.
 
 A bejárás végeztével, ismerve az oktális fa szerkezetét megállapíthatjuk, hogy a látható objektumok mindegyike ebben a térrészben található. A további láthatósági vizsgálatok tehát, kizárólag azon objektumokat érintik, amik a megtalált csúcshoz, vagy annak valamely gyermekéhez tartozó térrészben tartózkodnak, ezzel jelentõsen csökkentve az ellenõrzõ mûveletek számát.
 
\SubSection{GPU pufferek használata}

A grafikus könyvtárak, mint az OpenGL vagy a DirectX, elsõdleges célja a nagy teljesítményû grafikai számításokra optimalizált, grafikus vezérlõk alacsony szintû programozása. A vezérlõ kezelése mindig tartalmazza a következõ két lépést: a felhasznált adatok grafikus memóriában történõ tárolása (\textit{feltöltés}), valamint a tárolt adatok feldolgozása. Nem egyértelmû azonban, hogy az egyes lépések milyen részmûveletekkel és ezáltal milyen hatékonysággal mennek végbe.

Az OpenGL korai verziói kizárólag az úgy nevezett \textit{"immediate"}, azaz közvetlen adat feltöltést tették lehetõvé. Ez azt jelentette, hogy a rajzoláshoz szükséges adatokat (mint a \myref{SubSection:glmemory} fejezetben leírtak) minden egyes rajzolási ciklus kezdetekor a grafikus memóriába kellett másolni és onnan használni. Érthetõ okokból ez nem volt hatékony, hiszen a rajzolási folyamat minden esetben memória mûveleteket is vonzott magával.

A késõbbiekben bevezetésre kerültek a, már hatékonyabbnak bizonyuló, automatizált \textit{"fetch-stage"}-ek. Ez lehetõvé tette, hogy a szükséges adatok már nem "egyesével" kerültek a grafikus vezérlõhöz, hanem egy jól meghatározott fázisban, elõre definiált struktúrával. Ez azonban továbbra sem csökkentette a folyamatos másoláshoz szükséges erõforrás igényeket.

A következõ lépés a teljes mértékben grafikus memóriához dedikált puffer objektumok bevezetése volt. Az OpenGL környezetben ilyen objektumok létrehozhatóak a \textit{glGenBuffers} hívással. A GPU pufferek használatának egy hátránya lehet, hogy a feltöltött adat késõbbi változtatása kevésbé intuitiív, mint ha a program memóriájában kezelnék azt. Ezt azonban jelentõsen kompenzálja a használatból eredõ teljesítmény növekedés. A pufferek használata lehetõvé teszi, hogy egyszer legyen szükséges az adatok struktúrájának definiálása és azok GPU memóriába való feltöltése. A továbbiakban pedig a rajzolási mûveletek közvetlenül a puffer adataiból fognak dolgozni.

A már látott, geometriai adatokat tároló struktúrákból, a videómemóriába kerülnek a ponthalmazok, a \textit{mesh::post\_load} funkcióban. A \textit{post\_load} funkció kifejezetten arra a célra lett kialakítva a tartalom osztályok interfészében, hogy a sikeres, fájlból történõ betöltés után lehetõség legyen az adatok további kezelésére.

\begin{cpp}
...
glGenBuffers( 1, &m_buffer_names.position );
glBindBuffer( GL_ARRAY_BUFFER, m_buffer_names.position );
glBufferData( GL_ARRAY_BUFFER, sizeof( float ) * 3 * m_positions.size(), &m_positions[ 0 ], GL_STATIC_DRAW );
...
\end{cpp} 

Az "utó-töltés" során generálásra kerülnek a videómemóriához rendelt puffer objektumok (\textit{glGenBuffers}), majd minden egyes adattár (pozíció adatok, normál vektor adatok stb.) feltöltésre kerül a \textit{glBufferData} hívás segítségével.

\SubSection{Állapot átmenet optimalizáció OpenGL-ben}

Az OpenGL környezetre specifikus a \textit{grafikai állapotgép} jelleg. Ez azt jelenti, hogy a futási környezet (\textit{GL context}) viselkedését, illetve a kiadott parancsok hatását, minden pillanatban egy bizonyos számú állapotváltozó határozza meg. Ilyenek például, az aktuális használatban lévõ \textit{tömb puffer}, az aktuális mélységi ellenõrzés (\textit{depth test}) állapota, vagy a stencil mûveletekhez tartozó funkció típusa.

Ezen állapotok megváltoztatásához a legtöbb esetben a grafikus vezérlõre kiadott parancsra van szükség. Az ilyen parancsoknak azonban minden esetben van egy bizonyos plusz idõ költsége az általános függvény hívásokkal szemben, hiszen a mûveletek nem kizárólag a központi processzoron történõ számításokat eredményeznek, hanem külsõ hardver (GPU) "megszólítását" is. 

Annak érdekében tehát, hogy az állapot átmenetek minél kevésbé terheljék az alkalmazást, egy belsõ állapottérre van szükség. Ez egyszerûen azt jelenti, hogy azokat a kontextus változókat, amiket használunk (vagy amelyeket \textit{gyakran} használunk), az alkalmazás memóriájában is eltároljuk. Az állapotváltozók így két helyen lesznek tárolva. Ennek hátránya lehet a szinkronizációból eredõ problémák. Az alkalmazás oldali állapottér bevezetésével biztosítanunk kell, hogy a továbbiakban az állapotváltozók \textbf{lekérdezése} és \textbf{beállítása} kizárólag ezen állapottéren keresztül történik. 

Az állapottér jellemzõ mûvelete a lekérdezés és a beállítás mellett a \textit{feltöltés}. Ez a mûvelet jelenti a grafikus vezérlõ által tárolt állapottér frissítését, az alkalmazás oldali állapottér változóival.

Ennek a kialakításnak az elõnye, hogy az állapotok frissítése az alkalmazás egy jól meghatározott pontján történik, így az abból származó teljesítmény költséggel könnyen lehet számolni, és ami a legfontosabb: az állapotváltozók frissítésére kizárólag akkor kerül sor, ha valóban történt változás az alkalmazás oldali állapottérben. Ennek ellenõrzése pedig kisebb költségekkel jár, mint folyamatos, szükségtelen frissítéseket végezni.

