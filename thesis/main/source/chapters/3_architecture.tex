\Chapter{Rendszer architektúra}

\Section{Magas szintû áttekintés}

A \myref{fig:highlevelsystemovmin} ábrán láthatjuk a rendszer egy magas szintû, leegyszerûsített komponens diagramját. A rendszer öt fõ részbõl tevõdik össze. Négy különálló alrendszert képez a digitális tartalom nyílvántartó rendszer (\textit{Asset System}), a rendszer központi funkcióit összefoglaló alrendszer (\textit{Engine Core}), a szkript alrendszer (\textit{Script Backend}) és a grafikus alrendszer (\textit{Render System}). Az ábrán látható \textit{Script Interface} komponens pedig, az alrendszerek által, a szkript környezet felé szolgáltatott funkcionalitások összessége.

Az ábrán láthatóak továbbá, a komponensek közötti legfõbb kapcsolódási pontok. A nyílvántartó rendszer, a központi funkciók és a grafikus alrendszer közötti kapcsololatot a virtuális teret rendszerezõ fagráf jelenti. A fagráf egyes csúcsai egy úgy nevezett \textit{tartalom foglalaton} (a \myref{subsec:assetsocket} részben részletesebben lesz szó errõl) keresztül referálnak az aktuálisan hozzájuk rendelt tartalomra, a grafikus alrendszer pedig ezeket a tartalmakat dolgozza fel futása során, a gráf csúcsait bejárva.

Egy másik rendszerek közötti, gyengébb összefüggést jelent a konfigurációs megoldás. Ebben az esetben nincs szó konkrét funkcionális kapcsolatról, csupán a konfigurációs objektum megosztottsága, és a különbözõ alrendszerek által felhasznált konfigurációs paraméterek biztosítanak egy bizonyos fokú adat összefüggést (errõl a \myref{subsec:configuration} rész szól részletesebben).

Az utolsó, ábrán látható asszociációt pedig az úgy nevezett \textit{modellek} jelentik. Ezek olyan speciális objektumok, amik a különbözõ alrendszerek natív funkcionalitását hivatottak kiszolgáltatni a \textit{szkript felület} (Script Interface) felé (a \myref{subsec:models} részben láthatjuk hogyan).

\subsubsection{Fájl útvonalak}
A továbbiakban szerepelni fognak az említett koncepciókat és funkciókat megvalósító programkódok forrásainak elérési útvonala. Az útvonalakat egy egyszerûsített formában láthatjuk, mint például: \textit{core/multi\_thread}. Ennek értelmezéséhez a következõket szükséges figyelembe venni:

\begin{itemize}
\item Minden említett útvonal alapkönyvtára a \textbf{zhygraph} könyvtár.
\item Minden alrendszer saját könyvtára a \textbf{subsystem.zhygraph} elnevezési formát követi.
\item Sok esetben, a C++ nyelvre jellemzõ konvenció és programtechnikai okokból egy-egy osztály vagy funkció deklarációja és definíciója két részre van osztva. A deklaráció a \textbf{.h}, míg a definíció a \textbf{.cpp} kiterjesztésû fájlokban található. Az említett elérési útvonalak kiterjesztés nélkül szerepelnek, ami azt jelenti, hogy mind a két fájlra vonatkozik, amennyiben a kód két részre van osztva, valamint csak a \textbf{.h} kiterjesztésû fájlokra, ha nincs elérhetõ forrás fájl.
\end{itemize}

Ezek alapján a \textit{core/multi\_thread} útvonal, fizikailag a következõ fájlokra vonatkozik:
\begin{itemize}
\item \textit{zhygraph/core.zhygraph/multi\_thread.h}
\item \textit{zhygraph/core.zhygraph/multi\_thread.cpp}
\end{itemize}
Mivel az alapkönyvtár nem változik, illetve az alrendszer könyvtárak elnevezése is konzisztens, a leegyszerûsített útvonal mindig egyértelmû.

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/highlevelsystemovmin.eps, width=\textwidth, height=13.105cm}
\caption{Rendszer komponensek áttekintése}
\label{fig:highlevelsystemovmin}
\end{figure}

\Section{Központi funkciók}

A központi funkciók közé sorolunk minden olyan funkciót a rendszerben, ami nem tartozik szorosan egyik alrendszerhez sem, vagy több alrendszer által is felhasználásra kerül. Ide tartozik a már említett, virtuális teret reprezentáló fagráf, amit mind a grafikus mind pedig a nyílvántartó rendszer el kíván érni. Ezen kívül a konfigurációs osztályok, a futtatható \textit{referencia} alkalmazás "csontvázát" jelentõ osztályok, a rendszerüzenetek továbbítására szolgáló osztályok valamint egyéb segédfunkciók tartoznak ide.

\SubSection{Konfiguráció}
\label{subsec:configuration}

Konfigurációs paraméternek fogunk nevezni minden olyan típus-érték párt, ami az alkalmazás indulásakor egyszer töltõdik be, a futás során nem változik meg (sem a típusa, sem az értéke) és valamilyen módon hatással van egy alrendszer, vagy egy alrendszerben található funkció mûködésére.

A konfiguráció úgy nevezett \textit{INI} fájlokon keresztül történik. Az INI fájlformátum egy nem-hivatalos konfigurációs formátum bizonyos platformokon. Elõnye, hogy egyszerû, szöveg alapú fájlok, így könnyen szerkeszthetõek és olvashatóak. A formátum három összetevõje a \textit{szekciók}, az \textit{attribútumok} és az \textit{értékek} \cite{inifile}. A három összetevõ elrendezése a következõ:

\begin{lstlisting}
[section1]
attribute1=value1
attribute2=value2

[section2]
attribute3=value3
attribute4=value4
\end{lstlisting}

Egy INI formátum alapú konfiguráció implementáció található a \textit{core/config} útvonalon. A \textit{config} osztály egy aktuálisan betöltött INI fájlt reprezentál. A betöltést a \textit{load} függvénnyel lehet kezdeményezni, mely a konfigurációs fájl elérési útvonalát várja paraméterként. A sikeres betöltés után a \textit{group} hívással érhetõek el a különbözõ csoportok. Egy csoport elemei egy konkrét \textit{[section]} elem alá írt név-érték párok lesznek, a csoport neve pedig a zárójelek közé írt név. A group hívás visszatérési értéke egy csoport példány lesz. A csoportban definiált név-érték párok között a \textit{value, integer, number, test} funkciókkal lehet keresni, amik egyben a kívánt típussá - rendre karakterlánc, egész szám, tört szám, logikai érték - konvertálják az értéket.

\SubSection{Virtuális tér fagráf}

A virtuális tér elemeit, egy fagráfban tároljuk, tehát teljesülnek a következõk:
\begin{enumerate}
\item A gráf összefüggõ és nem tartalmaz kört
\item A gráfban egyszerû kör jön létre, ha hozzáadunk egy élt
\item A gráf nem marad összefüggõ ha eltávolítunk egy élt
\end{enumerate}

A gráfot irányítottnak tekintjük, hiszen a csúcsok között szülõ-gyermek viszonyt feltételezünk. Ezzel együtt teljesül az, hogy minden csúcsnak pontosan egy szülõje van, kivéve a gyökér elemet, aminek nincs szülõje. Továbbá minden csúcsnak tetszõleges számú gyermeke lehet.

A csúcsok viszonya az úgy nevezett \textit{hierarchikus transzformációk} miatt lényeges. Ennek alap ötlete, hogy minden egyes csúcshoz tartozik egy transzformáció, ami leírja a csúcs helyzetét, orientációját és skálázását. A transzformációk bázisa azonban mindig az aktuális csúcs szülõjének koordinátarendszere, aminek a "valós" térbeli elhelyezkedését a saját transzformációja, és az õ szüleinek transzformáció lánca határozza meg, rekurzívan.

A gyökér csúcs transzformációjához tartozó bázist tekintjük az abszolút bázisnak, amelyben a pontokat az úgy nevezett "világ" koordináták írnak le.

Ennek a rendszernek az elõnye, hogy a relatív transzformációk könnyedén modellezik a virtuális térben található objektumok kapcsolatát. Például tegyül fel, hogy el szeretnénk helyezni a térben egy lovat ábrázoló geometriát, valamint annak hátán egy lovast. A relatív transzformációk nélkül a lovas helyzetét is ugyanazon bázisban kellene meghatároznunk, mint a lóét, ami nem okozna problémát ha az objektumok között nem lenne semmilyen összefüggés. Jelen esetben, azonban nem egyszerûen egy lovat és egy lovast szeretnénk modellezni, hanem egy lovast, ami \textbf{rajta ül} egy lovon.

A különbség akkor lényeges, ha megváltozik a ló helyzete, például mert szeretnénk animálni annak mozgását illetve haladását. Az elsõ esetben a lovas a helyén maradna, a ló pedig "kimenne" alóla. Ennek korrigálására a ló helyzetét megváltoztató transzformációt alkalmaznunk kellene, külön a lovasra.

Két objektumra talán nem tûnik még komplikáltnak alkalmazni ugyanazon elmozdulást, képzeljük el azonban, ha a lovason található öltözékek mind-mind külön objektumok, a kezében pedig lovagló pálca van. Ebben az esetben a ló elmozdulását már jóval több objektumra kell alkalmazni, ami egyre komplikáltabb számításokat eredményez.

A problémára megoldást jelent a relatív transzformációk rendszere. Ezek alapján a lovast úgy modellezhetjük, hogy a ló bázisának az abszolút bázist tekintjük, a lovasénak a ló transzformációja által meghatározott rendszert, a lovas öltözékeinek helyzete pedig a lovashoz relatív értelemben van megállapítva.

A relatív transzformációkat magába foglaló, facsúcsokat reprezentáló osztályt láthatunk a \textit{core/scene\_node} útvonalon.

\SubSection{Alkalmazás szerkezet}

Mivel a tárgyalt alrendszerek dinamikus (vagy megosztott) könyvtárak létrehozására vannak tervezve, a rendszer használatához szükség van egy belépési pontra (\textit{main} függvény) is. Annak érdekében, hogy a belépési pont kódja minél letisztultabb legyen, a központi funkciók közé tartozik egy alkalmazás szerkezet is. Ennek a megvalósítása található a \textit{core/approot} útvonalon. Az \textit{application root} osztály három paramétert vár a konstruktorában, ezek határozzák meg, rendre a digitális tartalmak deklarációját tartalmazó fájl, az elsõdleges konfigurációs fájl és a virtuális tereket leíró fájl elérési útvonalát. Így az alkalmazás belépési pontja egészen egyszerû lesz:

\begin{cpp}
int main( int argc, char** argv ) {
  try {
    zhygraph::core::application_root 
	  app( "assets.ini", "config.ini", "scenes.sc" );
    app.initialize();
    app.run();
  } catch( const std::exception& e ) {
    std::cerr << e.what();
    return -1;
  }
  
  return 0;
}
\end{cpp}

Az \textit{initialize} függvény, létrehoz minden szükséges konfigurációs és alrendszer objektumot, és inicializálja azokat. A \textit{run} függvény pedig tartalmazza a futáshoz szükséges \textit{alkalmazás ciklust}.

\SubSection{Segédfunkciók és struktúrák}

\subsubsection{Szálkezelés}

A \textit{core/multi\_thread} útvonalon található a standard \textit{thread} osztály egy kiterjesztése. A standard szál objektumokat egy valamilyen \textit{callable} ("hívható") objektummal kell létrehoznunk, aminek a futtatása egy külön szálon fog történni, ezután azonban a szál objektum, valamint a hozzátartozó szál nem használható tovább. A \textit{multi-thread} osztály a szálak újrahasznosítását teszi lehetõvé, annak érdekében, hogy elkerüljük az újboli szál kreáció és szál-objektum példányosítás költségeit.

\subsubsection{Szál elosztás}

A \textit{multi\_thread\_distributor} osztály egy adott számú \textit{multi\_thread} objektumot kezel. Az osztály segítségével különbözõ szempontok szerint választhatunk ki egy-egy szálat. A következõ szempontok kerültek megvalósításra:
\begin{description}
\item \textit{Idle Thread} - olyan szál kerüljön kiválasztásra, amire nincs feladat bízva jelenleg
\item \textit{Least Job Thread} - olyan szál kerüljön kiválasztásra, aminek feladat száma minimális
\item \textit{Most Job Thread} - olyan szál kerüljön kiválasztásra, aminek feladat száma maximális
\end{description}

\subsubsection{Oktális fa}

A \textit{core/octree} útvonalon található egy dinamikus oktális fa implementációja. A megvalósításhoz tartozó két fõ osztály az \textit{octree\_node} és az \textit{octree}. Az elõbbi egy osztály sablon, aminek a paramétere egy "volume-type", tehát egy olyan absztrakt struktúra, ami megvalósítástól függõ módon ír le egy térrészt. Az utóbbi pedig csupán egy gyökér elemet biztosít a fa számára, valamint kivezeti a csúcsok publikus funkcióit. Az oktális fa mûködésérõl és alkalmazásáról részletes leírást láthatunk a \myref{section:optimalize} részben.

\SubSection{Rendszerüzenetek}

Annak érdekében, hogy a különbözõ rendszerfunkciók mûkõdésérõl valósidejû információkat kapjunk, illetve, hogy az esetlegesen felmerülõ hibák rögzítésre kerülhessenek bevezetünk egy rendszerüzenet kezelõ rendszert.

Az üzenet rendszer implementációja a \textit{core/logger} útvonalon található. A rendszer fõ osztálya a \textit{logger} osztály, amin keresztül elérhetõek a fõ funkciók. Az üzenetküldés alap funkciója a \textit{log} függvény, ami egy üzenetprioritást, egy üzenetet és az üzenet küldõ osztály nevét várja paraméterként.

Az üzenetek prioritásai a következõképpen alakulnak:

\begin{description}
\item \textit{debug} - olyan üzenet, ami a fejlesztés közben, fõleg hibakeresési célokkal jelenhet meg a fejlesztõ számára
\item \textit{info} - alapvetõ információ üzenet, a rendes mûködés menetérõl szolgáltat tájékoztatást
\item \textit{warn} - olyan üzenet, aminek kiváltó okáról nem dönthetõ el pontosan, hogy a rendes vagy a rendellenes mûködés része-e, a legtöbb esetben nem jelent veszélyt a program futására, de érdemes figyelni rá
\item \textit{error} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nem eredményezi a program leállását, azonban jelzi valamely funkció rendellenes mûködését, külsõ vagy belsõ okok is kiválthatják
\item \textit{fatal} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nagy valószínûséggel a program leállását fogja eredményezni, külsõ vagy belsõ okok is kiválthatják
\end{description}

Az üzenetek a \textit{log\_channel} interfészen keresztül kerülnek feldolgozásra. Az interfész célja, hogy különbözõ, egyedi megvalósításokat hozhassunk létre, az üzenetek kimenetelét tekintve. 

A \textit{stdout\_channel} implementáció, ahogy az elnevezése sugallja, a standard kimenetre írja a kapott üzeneteket (\textit{std::cerr} a hiba és \textit{std::cout} a nem hiba üzenetek kimenete ). A másik megvalósítás a \textit{file\_channel}, ami pedig a példányosításkor megadott fájlba írja az üzeneteit.

A rendszer úgy van megvalósítva, hogy tetszõleges számú \textit{csatorna} adható a rendszerhez, és mindegyik csatorna megkapja az összes küldött üzenetet, amivel aztán az implementációtól függõ mûvelet hajtódik végre.

\Section{A grafikus alrendszer}
\SubSection{Virtuális tér}
\SubSection{Digitális tartalom implementációk}
\SubSection{Grafikus vezérlõ osztály}
\SubSection{Grafikus állapottér}
\SubSection{Rendszer konfigurációk}

\Section{A tartalom nyílvántartó alrendszer}
\SubSection{Tartalom referencia}

Ahogy a \myref{chap:assetmanagement} részben részletezve láthatjuk, a digitális tartalmakat reprezentáló objektumokat egy másolás nélküli struktúrával valósítjuk meg, az objektumok megosztása referenciákon keresztül történik. A tartalom objektumokat a \textit{asset/asset\_base} útvonalon található fájlokban, míg a referencia objektumokat a \textit{asset/asset\_pointer} útvonalon található fájlokban valósítjuk meg. 

A referencia objektum publikus funkciói között fõként a tárolt objektum elérését szolgáló \textit{operátorokat}, valamint a referencia számláláshoz szükséges \textit{másoló konstruktorokat} találjuk. Megtalálható az osztályban továbbá, a referenciát birtokló nyílvántartó vezérlõ osztály pointere is. Erre azért van szükség, hogy a referencia számláló nullára csökkenésekor, az objektum jelzést tudjon küldeni a vezérlõ számára (\textit{notify\_unreferenced}).

A jelzéstõl eltekintve az osztály mûkõdése hasonló a standard, referencia számlált "okos-mutatók" mûködéséhez, mint például a \textit{std::shared\_pointer}. A konstruktor létrehoz egy közös memória területen tárolt változót, ami az aktuális referenciák számát tárolja. A másoló konstruktor növeli eggyel a referenciaszámlálót, míg a destruktor csökkenti eggyel, a számláló nullára csökkenésekor pedig megtörténik a számláló változó felszabadítása és a vezérlõ tájékoztatása.

\SubSection{Tartalom gyártó egység}

A \textit{asset/asset\_manager} útvonalon található \textit{asset\_factory} osztály célja, hogy regisztrált tartalom típusok alapján hozzon létre tartalom objektumokat. A mûködése egyszerûen egy asszociatív táron (\textit{std::unordered\_map}) alapul, aminek a kulcsa egy karakterlánc, típusa pedig egy függvény objektum. A típusok regisztrálása során megadásra kerül egy típus azonosító, ez lesz a kulcs, valamint egy fordítási idejû típus paraméter, amibõl pedig a függvény objektum kerül létrehozásra oly módon, hogy az objektum meghívása egy megfelelõ dinamikus-típusú, tartalom objektum létrehozását eredményezze.
 
\SubSection{Nyílvántartó vezérlõ osztály}

Szintén a \textit{asset/asset\_manager} útvonalon található a nyílvántartó rendszer központi osztálya, az \textit{asset\_manager} osztály. Ennek feladata, hogy létrehozza a gyártó egység segítségével a tartalom objektumokat, biztosítsa azokhoz az elérést, valamint, hogy kezelje a szemétgyûjtõ listát, amin a zérus referenciával rendelkezõ objektumok találhatóak.

Tartalmaz továbbá az osztály egy szál elosztó objektumot, ami a tartalmak betöltési funkcióit kapják feladatnak, valamint egy különálló OpenGL szálat. Erre azért van szükség mert az OpenGL kontextus mindig csak egy adott szálon lehet aktív, így a grafikus vezérlõtõl függõ objektumok csak ezen a szálon kerülhetnek betöltésre.

\SubSection{Tartalom "foglalat"}
\label{subsec:assetsocket}

A tartalom foglalat (\textit{asset socket}) feladata, hogy kihagyás-mentes átmenetet biztosítson tartalmak cseréje között. Például ha egy geometriai objektumot kicserélünk - annak érdekében, hogy az új objektum töltési ideje alatt is történjen megjelenítés - a régire történõ referenciát aktívan tartjuk, amíg az új betöltése véget nem ér.

A megvalósítás a \textit{asset/asset\_socket} útvonalon található. Az osztály egyetlen funkciója a \textit{swap}, ami a kívánt objektumot várja paraméterül.

\SubSection{Rendszer konfigurációk}

A nyílvántartó rendszer konfigurációit az \textbf{asset\_system} csoport alatt kell megadni és a lehetséges paraméterek a következõek:

\begin{description}
\item \textit{loader\_thread\_count[int]} - megadja, hogy a vezérlõ osztályban található szál-elosztó hány szálat tartalmazzon
\item \textit{gc\_policy[string]} - megadja, hogy milyen stratégia szerint kerüljenek felszabadításra a szemétgyûjtõ listáról az objektumok, lehetséges értékei a \textbf{least\_freed\_object} és a \textbf{leave\_biggest\_object}, a stratégiák leírását a \myref{section:gclist} részben találhatjuk
\end{description}

Így tehát a nyílvántartó rendszer egy lehetséges konfigurációs csoportja a következõképpen alakul:

\begin{lstlisting}
[asset_system]
loader_thread_count=4
gc_policy=least_freed_object
\end{lstlisting}

\Section{A szkript alrendszer}
\SubSection{Digitális tartalom implementáció}
\SubSection{Szkript vezérlõ osztály}
\SubSection{Szkript állapottér}
\SubSection{Modellek}
\label{subsec:models}
\SubSection{Rendszer konfigurációk}