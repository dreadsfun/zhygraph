\Chapter{Rendszer architektúra}

\Section{Magas szintû áttekintés}

A keretrendszer hat elkülöníthetõ részbõl tevõdik össze. Ezek a központi funkciókat összefogó rendszer, a reflexiót és függõség injektálást megvalósító rendszer, az alkalmazás indító rendszer, a grafikus alrendszer, a grafikus megjelenítéshez szükséges ablakozó rendszer, valamint a többi rendszer által, a szkript felület felé szolgáltatott funkciók összessége. A \myref{fig:highlevelov} ábrán láthatunk egy leegyszerûsített komponens diagramot. A továbbiakban az egyes összetevõk jellemzõit és azok felépítését részletezzük.

\subsubsection{Fájl útvonalak}
A továbbiakban szerepelni fognak az említett koncepciókat és funkciókat megvalósító programkódok forrásainak elérési útvonala. Az útvonalakat egy egyszerûsített formában láthatjuk, mint például: \textit{core/multi\_thread}. Ennek értelmezéséhez a következõket szükséges figyelembe venni:

\begin{itemize}
\item Minden említett útvonal alapkönyvtára a \textbf{zhygraph} könyvtár.
\item Sok esetben, a C++ nyelvre jellemzõ konvenció és programtechnikai okokból egy-egy osztály vagy funkció deklarációja és definíciója két részre van osztva. A deklaráció a \textbf{.hpp}, míg a definíció a \textbf{.cpp} kiterjesztésû fájlokban található. Az említett elérési útvonalak kiterjesztés nélkül szerepelnek, ami azt jelenti, hogy mind a két fájlra vonatkozik, amennyiben a kód két részre van osztva, valamint csak a \textbf{.hpp} kiterjesztésû fájlokra, ha nincs elérhetõ forrás fájl.
\end{itemize}

Ezek alapján a \textit{core/multi\_thread} útvonal, fizikailag a következõ fájlokra vonatkozik:
\begin{itemize}
\item \textit{zhygraph/core/multi\_thread.hpp}
\item \textit{zhygraph/core/multi\_thread.cpp}
\end{itemize}
Mivel az alapkönyvtár nem változik, illetve az alrendszer könyvtárak elnevezése is konzisztens, a leegyszerûsített útvonal mindig egyértelmû.

\Section{Függõség injektálás}

A \textit{dependency injection}, azaz "függõség injektálás" egy olyan program architektúra technika, ami egy rendszer, komponensekre történõ bontását és a komponensek közötti függõségek kezelését hivatott segíteni. Virtuális nyelvekben, ahol eredendõen rendelkezésre állnak a \textit{reflexió} technikái, mint a Java-ban, triviálisan megvalósítható és alkalmazható az injektálás. Más a helyzet azonban a C++ környezet esetén, hiszen nem áll rendelkezésre a reflexió és így az injektálás lehetõsége sem.

\SubSection{Reflexió C++-ban}

Egy programozási nyelv, vagy nyelvrendszer kontextusában reflexiónak nevezzük azt a eljárást, mely során a program futása közben - a programot alkotó struktúrákról (funkciók, osztályok, adattagok stb.) - elérhetõ adatokat generálunk. Az említett Java nyelvben például ez teljesen automatikusan történik, a C++ esetén azonban szükség van bizonyos "trükkökre" a megvalósításhoz.

A technika lényege, hogy fejlesztõként vállaljuk a felelõsséget, hogy a reflektálni kívánt osztályokat \textbf{manuálisan} tesszük elérhetõvé a futási környezet számára.

A \textit{di\_rtlib} könyvtárban található az injektáló rendszer egy megvalósítása. A \textit{register\_class.hpp} tartalma:

\begin{cpp}
#pragma once
#include "meta_class.hpp"
namespace di {
template< typename T >
class class_registrator {
public:
  class_registrator( const std::string& cl ) {
    class_registry::insert< T >( cl );
  }
};
#define register_class( clname )\
static ::di::class_registrator< clname >\
__register_ ##clname ##__ { #clname }
}
\end{cpp}

A \textit{register\_class} kifejezés jelenti a belépési pontot a reflektálás rendszerébe. Az ötlet az, hogy egy olyan osztályt definiálunk (\textit{class\_registrator}), ami a konstruktorában regisztrál egy osztályt, a megadott néven. A regisztráció során a névhez hozzárendelõdik egy funkció objektum (\textit{functor}), ami a regisztátor osztály típus paraméterébõl kerül kialakításra, úgy, hogy a funkció a megadott típust példányosítsa meghívásakor:

\begin{cpp}
template< typename T >
static void insert( const std::string& cn ) {
  auto fit = instance->m_classes.find( cn );
  if( fit == instance->m_classes.end() ) {
    auto ctor = []() -> component* {
      return static_cast< component* >( new T() );
    };
    instance->m_classes.emplace( cn, meta_class( cn, ctor ) );
  }
}
\end{cpp}

A \textit{register\_class} kifejezés egy regisztrátor példány létrehozását kezdeményezi, ami a program indulásakor (címtérbe történtõ betöltéskor, dinamikus könyvtár esetén) le is fut, innentõl automatizálva a folyamatot.

\SubSection{Komponensek és függõségek}
\SubSection{Attribútumok}
\SubSection{Komponens konfiguráció}

\Section{Központi funkciók}

A központi funkciók közé sorolunk minden olyan funkciót a rendszerben, ami nem tartozik szorosan egyik alrendszerhez sem, vagy több alrendszer által is felhasználásra kerül. Ide tartozik a már említett, virtuális teret reprezentáló fagráf, a szálkezeléssel kapcsolatos funkciók, az idõmérésre használt osztályok, a rendszerüzenetek küldésére megvalósított funkciók, valamint a nyílvántartó rendszer alapjai is.

\SubSection{Virtuális tér fagráf}

A virtuális tér elemeit, egy fagráfban tároljuk, tehát teljesülnek a következõk:
\begin{enumerate}
\item A gráf összefüggõ és nem tartalmaz kört
\item A gráfban egyszerû kör jön létre, ha hozzáadunk egy élt
\item A gráf nem marad összefüggõ ha eltávolítunk egy élt
\end{enumerate}

A gráfot irányítottnak tekintjük, hiszen a csúcsok között szülõ-gyermek viszonyt feltételezünk. Ezzel együtt teljesül az, hogy minden csúcsnak pontosan egy szülõje van, kivéve a gyökér elemet, aminek nincs szülõje. Továbbá minden csúcsnak tetszõleges számú gyermeke lehet.

A csúcsok viszonya az úgy nevezett \textit{hierarchikus transzformációk} miatt lényeges. Ennek alap ötlete, hogy minden egyes csúcshoz tartozik egy transzformáció, ami leírja a csúcs helyzetét, orientációját és skálázását. A transzformációk bázisa azonban mindig az aktuális csúcs szülõjének koordinátarendszere, aminek a "valós" térbeli elhelyezkedését a saját transzformációja, és az õ szüleinek transzformáció lánca határozza meg, rekurzívan.

A gyökér csúcs transzformációjához tartozó bázist tekintjük az abszolút bázisnak, amelyben a pontokat az úgy nevezett "világ" koordináták írnak le.

Ennek a rendszernek az elõnye, hogy a relatív transzformációk könnyedén modellezik a virtuális térben található objektumok kapcsolatát. Például tegyül fel, hogy el szeretnénk helyezni a térben egy lovat ábrázoló geometriát, valamint annak hátán egy lovast. A relatív transzformációk nélkül a lovas helyzetét is ugyanazon bázisban kellene meghatároznunk, mint a lóét, ami nem okozna problémát ha az objektumok között nem lenne semmilyen összefüggés. Jelen esetben, azonban nem egyszerûen egy lovat és egy lovast szeretnénk modellezni, hanem egy lovast, ami \textbf{rajta ül} egy lovon.

A különbség akkor lényeges, ha megváltozik a ló helyzete, például mert szeretnénk animálni annak mozgását illetve haladását. Az elsõ esetben a lovas a helyén maradna, a ló pedig "kimenne" alóla. Ennek korrigálására a ló helyzetét megváltoztató transzformációt alkalmaznunk kellene, külön a lovasra.

Két objektumra talán nem tûnik még komplikáltnak alkalmazni ugyanazon elmozdulást, képzeljük el azonban, ha a lovason található öltözékek mind-mind külön objektumok, a kezében pedig lovagló pálca van. Ebben az esetben a ló elmozdulását már jóval több objektumra kell alkalmazni, ami egyre komplikáltabb számításokat eredményez.

A problémára megoldást jelent a relatív transzformációk rendszere. Ezek alapján a lovast úgy modellezhetjük, hogy a ló bázisának az abszolút bázist tekintjük, a lovasénak a ló transzformációja által meghatározott rendszert, a lovas öltözékeinek helyzete pedig a lovashoz relatív értelemben van megállapítva.

A relatív transzformációkat magába foglaló, facsúcsokat reprezentáló osztályt láthatunk a \textit{core/scene\_node} útvonalon.

\SubSection{Segédfunkciók és struktúrák}

\subsubsection{Szálkezelés}

A \textit{core/multi\_thread} útvonalon található a standard \textit{thread} osztály egy kiterjesztése. A standard szál objektumokat egy valamilyen \textit{callable} ("hívható") objektummal kell létrehoznunk, aminek a futtatása egy külön szálon fog történni, ezután azonban a szál objektum, valamint a hozzátartozó szál nem használható tovább. A \textit{multi-thread} osztály a szálak újrahasznosítását teszi lehetõvé, annak érdekében, hogy elkerüljük az újboli szál kreáció és szál-objektum példányosítás költségeit.

\subsubsection{Oktális fa}

A \textit{core/octree} útvonalon található egy dinamikus oktális fa implementációja. A megvalósításhoz tartozó két fõ osztály az \textit{octree\_node} és az \textit{octree}. Az elõbbi egy osztály sablon, aminek a paramétere egy "volume-type", tehát egy olyan absztrakt struktúra, ami megvalósítástól függõ módon ír le egy térrészt. Az utóbbi pedig csupán egy gyökér elemet biztosít a fa számára, valamint kivezeti a csúcsok publikus funkcióit. Az oktális fa mûködésérõl és alkalmazásáról részletes leírást láthatunk a \myref{section:optimalize} részben.

\SubSection{Rendszerüzenetek}

Annak érdekében, hogy a különbözõ rendszerfunkciók mûkõdésérõl valósidejû információkat kapjunk, illetve, hogy az esetlegesen felmerülõ hibák rögzítésre kerülhessenek bevezetünk egy rendszerüzenet kezelõ rendszert.

Az üzenet rendszer implementációja a \textit{core/logger} útvonalon található. A rendszer fõ osztálya a \textit{logger} osztály, amin keresztül elérhetõek a fõ funkciók. Az üzenetküldés alap funkciója a \textit{log} függvény, ami egy üzenetprioritást, egy üzenetet és az üzenet küldõ osztály nevét várja paraméterként.

Az üzenetek prioritásai a következõképpen alakulnak:

\begin{description}
\item \textit{debug} - olyan üzenet, ami a fejlesztés közben, fõleg hibakeresési célokkal jelenhet meg a fejlesztõ számára
\item \textit{info} - alapvetõ információ üzenet, a rendes mûködés menetérõl szolgáltat tájékoztatást
\item \textit{warn} - olyan üzenet, aminek kiváltó okáról nem dönthetõ el pontosan, hogy a rendes vagy a rendellenes mûködés része-e, a legtöbb esetben nem jelent veszélyt a program futására, de érdemes figyelni rá
\item \textit{error} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nem eredményezi a program leállását, azonban jelzi valamely funkció rendellenes mûködését, külsõ vagy belsõ okok is kiválthatják
\item \textit{fatal} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nagy valószínûséggel a program leállását fogja eredményezni, külsõ vagy belsõ okok is kiválthatják
\end{description}

Az üzenetek a \textit{log\_channel} interfészen keresztül kerülnek feldolgozásra. Az interfész célja, hogy különbözõ, egyedi megvalósításokat hozhassunk létre, az üzenetek kimenetelét tekintve. 

A \textit{stdout\_channel} implementáció, ahogy az elnevezése sugallja, a standard kimenetre írja a kapott üzeneteket (\textit{std::cerr} a hiba és \textit{std::cout} a nem hiba üzenetek kimenete ). A másik megvalósítás a \textit{file\_channel}, ami pedig a példányosításkor megadott fájlba írja az üzeneteit.

A rendszer úgy van megvalósítva, hogy tetszõleges számú \textit{csatorna} adható a rendszerhez, és mindegyik csatorna megkapja az összes küldött üzenetet, amivel aztán az implementációtól függõ mûvelet hajtódik végre.

\Section{A tartalom nyílvántartó alrendszer}

A textit{core/asset} útvonalon található minden osztály és funkció, ami a nyílvántartó rendszerhez szükséges. Ezek az osztályok alapul szolgálnak a konkrét tartalom típusok implementációihoz, amiket láthatunk majd az alrendszerek részletezésénél.

\SubSection{Tartalom osztályok alapja}

Minden tartalom típus õsosztálya a \textit{asset\_base} osztály, illetve az absztrakt interfész az \textit{i\_asset}. Az alap osztály tartalmaz néhány olyan adattagot, ami bármely tartalom típusra jellemzõ lehet. Ilyen a tartalom fájl útvonalát jelzõ tag (\textit{m\_path:asset\_url}), az objektum aktuális állapota (\textit{m\_state:asset\_state}), valamint egy egyedi konfigurációs objektum, ami egy-egy tartalomhoz kapcsolódó betöltési paraméterek tárolására alkalmas.

Az alaposztály publikus interfésze az említett tagok lekérdezése és/vagy beállítására szolgáltat funkciókat, illetve a tartalom, memóriába történõ betöltését lehet kezdeményezni rajta keresztül.

\SubSection{Tartalom paraméterek}

Egy tartalom fájl inicializálásakor a rendszer automatikusan ellenõrzi, hogy létezik-e a tartalomról adatokat szolgáltató \textit{meta-fájl}. A fájl elnevezési konvenciója a \textit{eredetinev\_meta} formát követi:

\begin{cpp}
...
asset_url metaurl( url.format() + "_meta" );
if( m_streamer->check_asset( metaurl ) ) {
  asset_params prs( m_streamer->load_data( metaurl ) );
  if( prs.parse() ) {
    for( const auto& pp : prs.get_params() ) {
      nass->set_load_param( pp.first, pp.second );
      sinfo << "asset \"" << url.get_name() <<
        "\" param: " << pp.first << " value: " << pp.second;
	}
  }
}
...
\end{cpp}

Ha létezik a meta-fájl, az beolvasásra kerül, majd az adatot a \textit{asset\_params} osztály kapja meg. Az osztály egyetlen feladata, hogy név-érték párokra bontsa le a fájlban megadott paramétereket. A fájl struktúrája, ezen feladat támogatására, a lehetõ legegyszerûbb módon van kialakítva: minden sorban egy névnek és egy értéknek kell szerepelnie, egyenlõség (=) jellel elválasztva.

A lehetséges paraméterek egyediek minden tartalom típusra. A textúrákra jellemzõ paraméter például a "szûrési" technika:

\begin{cpp}
...
filter_mode=trilinear
...
\end{cpp}

\SubSection{Tartalom típus nyílvántartó osztály}

A tartalom nyílvántartás két lépcsõben történik. Az elsõ lépésben a különbözõ típusokat, és az azokhoz tartozó nyílvántartó objektumokat struktúráljuk. A következõ lépésben pedig, egy adott típushoz tartozó objektumokat rendszerezzük, mint például a textúrák.

Az elsõ lépés megvalósításához kialakított interfész a \textit{i\_asset\_type\_manager}. 
\begin{cpp}
class i_asset_type_manager {
public:
  virtual asset_manager_ptr get( const std::string& ty ) const = 0;
  virtual std::vector< asset_manager_ptr > get_all( void ) const = 0;
  virtual std::vector< std::string > get_types( void ) const = 0;
};
\end{cpp}
A feladata egyszerû, valamilyen módon szolgáltatnia kell az összes elérhetõ típus listáját, az összes, típushoz regisztrált nyílvántartó objektumot, valamint egy konkrét típushoz tartozó nyílvántartó objektumot.

Az interfész implementációja egy injektálható komponens, ami a függõségein keresztül éri el az egyes nyílvántartó objektumokat, és az ahhoz tartozó tartalom típusokat (\textit{asset.cpp - asset\_type\_manager}).

\SubSection{Tartalom nyílvántartó osztály}



\Section{A grafikus alrendszer}
\SubSection{Digitális tartalom implementációk}
\SubSection{Anyagtulajdonságok könyvtára}
\SubSection{Grafikus vezérlõ osztály}
\SubSection{Grafikus állapottér}