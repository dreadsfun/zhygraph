\Chapter{Rendszer architektúra}

\Section{Magas szintû áttekintés}

A keretrendszer hat elkülöníthetõ részbõl tevõdik össze. Ezek a központi funkciókat összefogó rendszer, a reflexiót és függõség injektálást megvalósító rendszer, az alkalmazás indító rendszer, a grafikus alrendszer, a grafikus megjelenítéshez szükséges ablakozó rendszer, valamint a többi rendszer által, a szkript felület felé szolgáltatott funkciók összessége. A \myref{fig:highlevelov} ábrán láthatunk egy leegyszerûsített komponens diagramot. A továbbiakban az egyes összetevõk jellemzõit és azok felépítését részletezzük.

\subsubsection{Fájl útvonalak}
A továbbiakban szerepelni fognak az említett koncepciókat és funkciókat megvalósító programkódok forrásainak elérési útvonala. Az útvonalakat egy egyszerûsített formában láthatjuk, mint például: \textit{core/multi\_thread}. Ennek értelmezéséhez a következõket szükséges figyelembe venni:

\begin{itemize}
\item Minden említett útvonal alapkönyvtára a \textbf{zhygraph} könyvtár.
\item Sok esetben, a C++ nyelvre jellemzõ konvenció és programtechnikai okokból egy-egy osztály vagy funkció deklarációja és definíciója két részre van osztva. A deklaráció a \textbf{.hpp}, míg a definíció a \textbf{.cpp} kiterjesztésû fájlokban található. Az említett elérési útvonalak kiterjesztés nélkül szerepelnek, ami azt jelenti, hogy mind a két fájlra vonatkozik, amennyiben a kód két részre van osztva, valamint csak a \textbf{.hpp} kiterjesztésû fájlokra, ha nincs elérhetõ forrás fájl.
\end{itemize}

Ezek alapján a \textit{core/multi\_thread} útvonal, fizikailag a következõ fájlokra vonatkozik:
\begin{itemize}
\item \textit{zhygraph/core/multi\_thread.hpp}
\item \textit{zhygraph/core/multi\_thread.cpp}
\end{itemize}
Mivel az alapkönyvtár nem változik, illetve az alrendszer könyvtárak elnevezése is konzisztens, a leegyszerûsített útvonal mindig egyértelmû.

\Section{Függõség injektálás}

A \textit{dependency injection}, azaz "függõség injektálás" egy olyan program architektúra technika, ami egy rendszer, komponensekre történõ bontását és a komponensek közötti függõségek kezelését hivatott segíteni. Virtuális nyelvekben, ahol eredendõen rendelkezésre állnak a \textit{reflexió} technikái, mint a Java-ban, triviálisan megvalósítható és alkalmazható az injektálás. Más a helyzet azonban a C++ környezet esetén, hiszen nem áll rendelkezésre a reflexió és így az injektálás lehetõsége sem.

Injektálásnak azt a módszert nevezzük, ahogy látszólag automatikusan, transzparensen történik a komponensek közötti függõségek feloldása. Nem szükséges tehát valamilyen komponens-specifikus, explicit módon (konstruktorban átadva, funkcióval beállítva stb.) értéket adni egy-egy objektum referenciának, hanem azok egy konfiguráció alapján létrehozásra és beállításra kerülnek.

\SubSection{Reflexió C++-ban}

Egy programozási nyelv, vagy nyelvrendszer kontextusában reflexiónak nevezzük azt a eljárást, mely során a program futása közben - a programot alkotó struktúrákról (funkciók, osztályok, adattagok stb.) - elérhetõ adatokat generálunk. Az említett Java nyelvben például ez teljesen automatikusan történik, a C++ esetén azonban szükség van bizonyos "trükkökre" a megvalósításhoz.

A technika lényege, hogy fejlesztõként vállaljuk a felelõsséget, hogy a reflektálni kívánt osztályokat \textbf{manuálisan} tesszük elérhetõvé a futási környezet számára.

A \textit{di\_rtlib} könyvtárban található az injektáló rendszer egy megvalósítása. A \textit{register\_class.hpp} tartalma:

\begin{cpp}
#pragma once
#include "meta_class.hpp"
namespace di {
template< typename T >
class class_registrator {
public:
  class_registrator( const std::string& cl ) {
    class_registry::insert< T >( cl );
  }
};
#define register_class( clname )\
static ::di::class_registrator< clname >\
__register_ ##clname ##__ { #clname }
}
\end{cpp}

A \textit{register\_class} kifejezés jelenti a belépési pontot a reflektálás rendszerébe. Az ötlet az, hogy egy olyan osztályt definiálunk (\textit{class\_registrator}), ami a konstruktorában regisztrál egy osztályt, a megadott néven. A regisztráció során a névhez hozzárendelõdik egy funkció objektum (\textit{functor}), ami a regisztátor osztály típus paraméterébõl kerül kialakításra, úgy, hogy a funkció a megadott típust példányosítsa meghívásakor:

\begin{cpp}
template< typename T >
static void insert( const std::string& cn ) {
  auto fit = instance->m_classes.find( cn );
  if( fit == instance->m_classes.end() ) {
    auto ctor = []() -> component* {
      return static_cast< component* >( new T() );
    };
    instance->m_classes.emplace( cn, meta_class( cn, ctor ) );
  }
}
\end{cpp}

A \textit{register\_class} kifejezés egy regisztrátor példány létrehozását kezdeményezi, ami a program indulásakor (címtérbe történtõ betöltéskor, dinamikus könyvtár esetén) le is fut, innentõl automatizálva a folyamatot.

A módszer elõnye, hogy az így reflektált osztályokat használni tudjuk anélkül, hogy az õt felhasználó kód bármit is tudna róla. Csupán egy publikus interfészt kell deklarálnunk, elérhetõ helyen, az implementáció pedig akár a forrás fájlba is kerülhet, ezzel maximálisan eleget téve az adat-rejtés elvének.

\SubSection{Komponensek és függõségek}

Ahhoz, hogy egy osztály részt vehessen a reflexióban, illetve a függõségek kezelésében, a \textit{component} osztályból kell örökölnie (\textit{di\_rtlib/component}). Ez az osztály tárolja a függõségek referenciáit és a reflektált osztály \textit{meta-osztályát}, illetve biztosítja, hogy kizárólag az osztályon belülrõl történjen függõség deklaráció.

Az osztály függõségeit a \textit{di\_rtlib/define\_dependency.hpp} fájlban található makrókkal lehet deklarálni (illetve lehet a makrók használata nélkül is, de jelentõsen bonyolultabb lenne úgy). A technika hasonló a reflektálásnál leírthoz: egy olyan objektumot deklarálunk az osztályban, ami a konstruktorában "automatikusan" regisztrálja a megadott nevet és típust, mint az osztály egy függõsége. A késõbbiekben ezen a néven keresztül lehet majd injektálni az osztály által igényelt komponenst.

\begin{cpp}
...
class asset_type_manager
  : public i_asset_type_manager, public di::component {
private:
  component_dependency( m_logger, i_logger );
  component_dependencies( m_managers, i_asset_manager );
...
\end{cpp}

\SubSection{Attribútumok}

A reflexió lehetõségeit kihasználva, a rendszer biztosítja a komponensekre vonatkozó egyedi attribútumok deklarálását is. Az attribútumok olyan primitív értékek, vagy primitív értékek kollekciói (primitívnek tekintve a karakterláncot is), amik a komponens konfigurációban, a függõségek mellett injektálásra kerülhetnek. Az attribútumok deklarálására szintén létrejött egy "segédmakró", ami a \textit{di\_rtlib/define\_attribute.hpp} fájlban található.

\begin{cpp}
...
class file_channel
  : public i_log_channel, public di::component {
private:
  component_attribute( m_file, std::string );
  mutable std::mutex m_stream_lock;
...
\end{cpp}

\SubSection{Komponens konfiguráció}

A rendszer különbözõ részei végül egy konfigurációs fájlban futnak össze. Jelen esetben ez az \textit{engine.conf} fájl, ami elengedethetetlen a keretrendszer futtatásához, automatikusan ezen a néven van keresve, közvetlenül a keretrendszer könyvtárában (önálló futtatás esetén, a futtatható állomány mellett).

A konfigurációs fájl egy standard XML fájl, aminek a struktúráját egy \textit{XSD séma} írja le (\textit{di/di.xsd}). A gyökér elem minden esetben a \textit{DI} kifejezés, ennek közvetlen gyermekei lehetnek a \textit{plugins}, a \textit{components} és a \textit{wiring}.

A \textit{plugins} tag alatt deklarálhatunk megosztott (dinamikusan linkelt) könyvtárakat, amiket a keretrendszer használni fog. Erre azért van szükség, mert a könyvtárak által reflektált osztályok és attribútumok csak akkor kerülnek regisztrálásra, ha azok be vannak töltve. Betöltés azonban nem történik automatikusan, hiszen nincs statikus kapcsolat a dinamikus könyvtárak és a futtatható állomány között.

A \textit{components} tag alatt kell felsorolnunk minden komponenst, amit létre szeretnénk hozni. Egy komponens deklarációjához mindenképpen szükség van egy névre (\textit{name}) és egy osztályra (\textit{class}):

\begin{xml}
...
<component name="graphics_context" class="win32gl_context"/>
...
\end{xml}

A névvel a késõbbiekben hivatkozunk a komponensre, amikor ezen komponens függõségeit kívánjuk beállítani, vagy a komponenst szeretnénk átadni függõségként. Az osztály paraméternek egy reflektált osztálynak kell lennie, ezzel a dinamikus típussal lesz létrehozva a komponens.

A komponensek deklarációjakor állíthatjuk be a reflektált osztályban megadott attribútumokat is:

\begin{xml}
...
<component name="material_library" class="material_library">
  <attribute name="material_file" value="text@materials"/>
</component>
...
\end{xml}

A \textit{wiring} rész alatt szereplhetnek az \textit{inject}, \textit{inject-one}, \textit{inject-slot} és az \textit{inject-all} tagok, melyek mindegyike a függõségek beállítására alkalmas, különbözõ szempontok szerint. 

Az \textit{inject} tagnak szükséges attribútumnak megadni egy fogadó komponenst, egy injektált komponenst, és azt, hogy a fogadó komponens mely függõsége az, amit felold ez az injekció (\textit{slot}).

\begin{xml}
...
<inject receiver="engine_launcher" 
  slot="windowing" injection="windowing"/>
...
\end{xml}

Az \textit{inject-one} tag arra való, hogy egy megadott komponens összes függõséget beállítsuk egy blokkon belül. A \textit{receiver} határozza meg a cél komponenst, a további \textit{inject} tagokkal pedig egy-egy függõséget oldhatunk fel, a válaszott komponensekkel (\textit{injection}).

\begin{xml}
...
<inject_one receiver="resource_context_handle">
  <inject slot="windowing" injection="windowing"/>
  <inject slot="resource_context" injection="graphics_resource_context"/>
  <inject slot="main_context" injection="graphics_context"/>
</inject_one>
...
\end{xml}

Az \textit{inject-slot} taggal egy megadott elnevezésû függõséget állíthatunk be egyszerre az összes komponensben (amiben szerepel), egy megadott komponenssel. Például majd mindegyik komponens használja az üzenetküldõ komponenst, így célszerû egy taggal injektálni az összes függõséget:

\begin{xml}
...
<inject_slot slot="logger" injection="default_logger"/>
...
\end{xml}

Az \textit{inject-all} taggal az injektálni kívánt komponenst rögzíthetjük, és azt sorolhatjuk fel, hogy mely komponensek, mely függõségeibe szeretnénk beállítani azt. Például ha csak a kiválasztott komponensekben szeretnénk beállítani az üzenetküldõ rendszert, nem az összesben:

\begin{xml}
...
<inject_all injection="default_logger">
  ...
  <inject receiver="text_manager" slot="logger"/>
  <inject receiver="shader_manager" slot="logger"/>
  ...
</inject_all>
...
\end{xml}

\Section{Központi funkciók}

A központi funkciók közé sorolunk minden olyan funkciót a rendszerben, ami nem tartozik szorosan egyik alrendszerhez sem, vagy több alrendszer által is felhasználásra kerül. Ide tartozik a már említett, virtuális teret reprezentáló fagráf, a szálkezeléssel kapcsolatos funkciók, az idõmérésre használt osztályok, a rendszerüzenetek küldésére megvalósított funkciók, valamint a nyílvántartó rendszer alapjai is.

\SubSection{Virtuális tér fagráf}

A virtuális tér elemeit, egy fagráfban tároljuk, tehát teljesülnek a következõk:
\begin{enumerate}
\item A gráf összefüggõ és nem tartalmaz kört
\item A gráfban egyszerû kör jön létre, ha hozzáadunk egy élt
\item A gráf nem marad összefüggõ ha eltávolítunk egy élt
\end{enumerate}

A gráfot irányítottnak tekintjük, hiszen a csúcsok között szülõ-gyermek viszonyt feltételezünk. Ezzel együtt teljesül az, hogy minden csúcsnak pontosan egy szülõje van, kivéve a gyökér elemet, aminek nincs szülõje. Továbbá minden csúcsnak tetszõleges számú gyermeke lehet.

A csúcsok viszonya az úgy nevezett \textit{hierarchikus transzformációk} miatt lényeges. Ennek alap ötlete, hogy minden egyes csúcshoz tartozik egy transzformáció, ami leírja a csúcs helyzetét, orientációját és skálázását. A transzformációk bázisa azonban mindig az aktuális csúcs szülõjének koordinátarendszere, aminek a "valós" térbeli elhelyezkedését a saját transzformációja, és az õ szüleinek transzformáció lánca határozza meg, rekurzívan.

A gyökér csúcs transzformációjához tartozó bázist tekintjük az abszolút bázisnak, amelyben a pontokat az úgy nevezett "világ" koordináták írnak le.

Ennek a rendszernek az elõnye, hogy a relatív transzformációk könnyedén modellezik a virtuális térben található objektumok kapcsolatát. Például tegyül fel, hogy el szeretnénk helyezni a térben egy lovat ábrázoló geometriát, valamint annak hátán egy lovast. A relatív transzformációk nélkül a lovas helyzetét is ugyanazon bázisban kellene meghatároznunk, mint a lóét, ami nem okozna problémát ha az objektumok között nem lenne semmilyen összefüggés. Jelen esetben, azonban nem egyszerûen egy lovat és egy lovast szeretnénk modellezni, hanem egy lovast, ami \textbf{rajta ül} egy lovon.

A különbség akkor lényeges, ha megváltozik a ló helyzete, például mert szeretnénk animálni annak mozgását illetve haladását. Az elsõ esetben a lovas a helyén maradna, a ló pedig "kimenne" alóla. Ennek korrigálására a ló helyzetét megváltoztató transzformációt alkalmaznunk kellene, külön a lovasra.

Két objektumra talán nem tûnik még komplikáltnak alkalmazni ugyanazon elmozdulást, képzeljük el azonban, ha a lovason található öltözékek mind-mind külön objektumok, a kezében pedig lovagló pálca van. Ebben az esetben a ló elmozdulását már jóval több objektumra kell alkalmazni, ami egyre komplikáltabb számításokat eredményez.

A problémára megoldást jelent a relatív transzformációk rendszere. Ezek alapján a lovast úgy modellezhetjük, hogy a ló bázisának az abszolút bázist tekintjük, a lovasénak a ló transzformációja által meghatározott rendszert, a lovas öltözékeinek helyzete pedig a lovashoz relatív értelemben van megállapítva.

A relatív transzformációkat magába foglaló, facsúcsokat reprezentáló osztályt láthatunk a \textit{core/scene\_node} útvonalon.

\SubSection{Segédfunkciók és struktúrák}

\subsubsection{Szálkezelés}

A \textit{core/multi\_thread} útvonalon található a standard \textit{thread} osztály egy kiterjesztése. A standard szál objektumokat egy valamilyen \textit{callable} ("hívható") objektummal kell létrehoznunk, aminek a futtatása egy külön szálon fog történni, ezután azonban a szál objektum, valamint a hozzátartozó szál nem használható tovább. A \textit{multi-thread} osztály a szálak újrahasznosítását teszi lehetõvé, annak érdekében, hogy elkerüljük az újboli szál kreáció és szál-objektum példányosítás költségeit.

\subsubsection{Oktális fa}

A \textit{core/octree} útvonalon található egy dinamikus oktális fa implementációja. A megvalósításhoz tartozó két fõ osztály az \textit{octree\_node} és az \textit{octree}. Az elõbbi egy osztály sablon, aminek a paramétere egy "volume-type", tehát egy olyan absztrakt struktúra, ami megvalósítástól függõ módon ír le egy térrészt. Az utóbbi pedig csupán egy gyökér elemet biztosít a fa számára, valamint kivezeti a csúcsok publikus funkcióit. Az oktális fa mûködésérõl és alkalmazásáról részletes leírást láthatunk a \myref{section:optimalize} részben.

\SubSection{Rendszerüzenetek}

Annak érdekében, hogy a különbözõ rendszerfunkciók mûkõdésérõl valósidejû információkat kapjunk, illetve, hogy az esetlegesen felmerülõ hibák rögzítésre kerülhessenek bevezetünk egy rendszerüzenet kezelõ rendszert.

Az üzenet rendszer implementációja a \textit{core/logger} útvonalon található. A rendszer fõ osztálya a \textit{logger} osztály, amin keresztül elérhetõek a fõ funkciók. Az üzenetküldés alap funkciója a \textit{log} függvény, ami egy üzenetprioritást, egy üzenetet és az üzenet küldõ osztály nevét várja paraméterként.

Az üzenetek prioritásai a következõképpen alakulnak:

\begin{description}
\item \textit{debug} - olyan üzenet, ami a fejlesztés közben, fõleg hibakeresési célokkal jelenhet meg a fejlesztõ számára
\item \textit{info} - alapvetõ információ üzenet, a rendes mûködés menetérõl szolgáltat tájékoztatást
\item \textit{warn} - olyan üzenet, aminek kiváltó okáról nem dönthetõ el pontosan, hogy a rendes vagy a rendellenes mûködés része-e, a legtöbb esetben nem jelent veszélyt a program futására, de érdemes figyelni rá
\item \textit{error} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nem eredményezi a program leállását, azonban jelzi valamely funkció rendellenes mûködését, külsõ vagy belsõ okok is kiválthatják
\item \textit{fatal} - olyan \textbf{hiba} üzenet, aminek kiváltó oka nagy valószínûséggel a program leállását fogja eredményezni, külsõ vagy belsõ okok is kiválthatják
\end{description}

Az üzenetek a \textit{log\_channel} interfészen keresztül kerülnek feldolgozásra. Az interfész célja, hogy különbözõ, egyedi megvalósításokat hozhassunk létre, az üzenetek kimenetelét tekintve. 

A \textit{stdout\_channel} implementáció, ahogy az elnevezése sugallja, a standard kimenetre írja a kapott üzeneteket (\textit{std::cerr} a hiba és \textit{std::cout} a nem hiba üzenetek kimenete ). A másik megvalósítás a \textit{file\_channel}, ami pedig a példányosításkor megadott fájlba írja az üzeneteit.

A rendszer úgy van megvalósítva, hogy tetszõleges számú \textit{csatorna} adható a rendszerhez, és mindegyik csatorna megkapja az összes küldött üzenetet, amivel aztán az implementációtól függõ mûvelet hajtódik végre.

\Section{A tartalom nyílvántartó alrendszer}

A textit{core/asset} útvonalon található minden osztály és funkció, ami a nyílvántartó rendszerhez szükséges. Ezek az osztályok alapul szolgálnak a konkrét tartalom típusok implementációihoz, amiket láthatunk majd az alrendszerek részletezésénél.

\SubSection{Tartalom osztályok alapja}

Minden tartalom típus õsosztálya a \textit{asset\_base} osztály, illetve az absztrakt interfész az \textit{i\_asset}. Az alap osztály tartalmaz néhány olyan adattagot, ami bármely tartalom típusra jellemzõ lehet. Ilyen a tartalom fájl útvonalát jelzõ tag (\textit{m\_path:asset\_url}), az objektum aktuális állapota (\textit{m\_state:asset\_state}), valamint egy egyedi konfigurációs objektum, ami egy-egy tartalomhoz kapcsolódó betöltési paraméterek tárolására alkalmas.

Az alaposztály publikus interfésze az említett tagok lekérdezése és/vagy beállítására szolgáltat funkciókat, illetve a tartalom, memóriába történõ betöltését lehet kezdeményezni rajta keresztül.

\SubSection{Tartalom paraméterek}

Egy tartalom fájl inicializálásakor a rendszer automatikusan ellenõrzi, hogy létezik-e a tartalomról adatokat szolgáltató \textit{meta-fájl}. A fájl elnevezési konvenciója a \textit{eredetinev\_meta} formát követi:

\begin{cpp}
...
asset_url metaurl( url.format() + "_meta" );
if( m_streamer->check_asset( metaurl ) ) {
  asset_params prs( m_streamer->load_data( metaurl ) );
  if( prs.parse() ) {
    for( const auto& pp : prs.get_params() ) {
      nass->set_load_param( pp.first, pp.second );
      sinfo << "asset \"" << url.get_name() <<
        "\" param: " << pp.first << " value: " << pp.second;
	}
  }
}
...
\end{cpp}

Ha létezik a meta-fájl, az beolvasásra kerül, majd az adatot a \textit{asset\_params} osztály kapja meg. Az osztály egyetlen feladata, hogy név-érték párokra bontsa le a fájlban megadott paramétereket. A fájl struktúrája, ezen feladat támogatására, a lehetõ legegyszerûbb módon van kialakítva: minden sorban egy névnek és egy értéknek kell szerepelnie, egyenlõség (=) jellel elválasztva.

A lehetséges paraméterek egyediek minden tartalom típusra. A textúrákra jellemzõ paraméter például a "szûrési" technika:

\begin{cpp}
...
filter_mode=trilinear
...
\end{cpp}

\SubSection{Tartalom típus nyílvántartó osztály}

A tartalom nyílvántartás két lépcsõben történik. Az elsõ lépésben a különbözõ típusokat, és az azokhoz tartozó nyílvántartó objektumokat struktúráljuk. A következõ lépésben pedig, egy adott típushoz tartozó objektumokat rendszerezzük, mint például a textúrák.

Az elsõ lépés megvalósításához kialakított interfész a \textit{i\_asset\_type\_manager}. 
\begin{cpp}
class i_asset_type_manager {
public:
  virtual asset_manager_ptr get( const std::string& ty ) const = 0;
  virtual std::vector< asset_manager_ptr > get_all( void ) const = 0;
  virtual std::vector< std::string > get_types( void ) const = 0;
};
\end{cpp}
A feladata egyszerû, valamilyen módon szolgáltatnia kell az összes elérhetõ típus listáját, az összes, típushoz regisztrált nyílvántartó objektumot, valamint egy konkrét típushoz tartozó nyílvántartó objektumot.

Az interfész implementációja egy injektálható komponens, ami a függõségein keresztül éri el az egyes nyílvántartó objektumokat, és az ahhoz tartozó tartalom típusokat (\textit{asset.cpp - asset\_type\_manager}).

\SubSection{Tartalom nyílvántartó osztály}

A nyílvántartó osztály interfésze az \textit{i\_asset\_manager}, melynek funkciói egy-egy tartalom betöltésére illetve felszabadítására vonatkoznak. Az interfész alap implementációja az \textit{asset\_manager\_base}. Ez implementálja az interfész minden funkcióját, a \textit{get\_type} híváson kívül, ami arra szolgál, hogy az adott tartalom típus nevét, karakterlánc formátumban adja meg. Ezen kívül az alap megvalósítás bevezet egy úgy tisztán virtuális függvényt:
\begin{cpp}
virtual asset_ptr create_asset( const asset_url& url ) = 0;
\end{cpp}
ami arra szolgál, hogy létrehozza az implementációtól függõ tartalom objektumot, a megfelelõ dinamikus típussal.

\Section{A grafikus alrendszer}
\SubSection{Digitális tartalom implementációk}

A grafikus alrendszer jelenleg három tartalom típust implementál, ezek a \textit{shader}, a \textit{texture} és a \textit{mesh} típusok (\textit{ogl\_graphics/ogl\_asset.cpp}). Az implementációkban található minden olyan funkció, ami specifikus az OpenGL környezetre, és az OpenGL objektumok létrehozására. Például a textúra betöltése során létrehozunk egy grafikus textúra objektumot:
\begin{cpp}
...
if( error == 0 ) {
  glGenTextures( 1, &m_gl_name );
  r = true;
} else {
  err = "image decoder error: ";
  err.append( lodepng_error_text( error ) );
}
...
\end{cpp}
A betöltési paraméterek feldolgozása történik a \textit{\_set\_wrap\_mode}, \textit{\_set\_filter\_mode} és \textit{\_set\_aniso} függvényekben, OpenGL hívások segítségével.

Az árnyékoló programok betöltése és fordítása történik, a \textit{shader} tartalom típus betöltési funkciójában:
\begin{cpp}
...
m_gl_name = glCreateShader( 
  string_to_shader_type( this->get_load_param( "shader_type" ) ) );
const char* src = data.c_str();
GLint lt = data.length();
glShaderSource( m_gl_name, 1, &src, &lt );
glCompileShader( m_gl_name );

GLint ccst = 0;
glGetShaderiv( m_gl_name, GL_COMPILE_STATUS, &ccst );

if( ccst != GL_TRUE ) {
  GLint llt = 0;
  glGetShaderiv( m_gl_name, GL_INFO_LOG_LENGTH, &llt );
  err.resize( llt );
  glGetShaderInfoLog( m_gl_name, llt, nullptr, &err[ 0 ] );
  glDeleteShader( m_gl_name );
  m_gl_name = 0;
  err.insert( 0, "failed to compile shader: " );
} else {
  r = true;
}
...
\end{cpp}

\SubSection{Grafikus vezérlõ osztály}

Az \textit{ogl\_graphics/ogl\_graphics.cpp} fájlban található a grafikus rendszer központi osztályának az implementációja. Az osztály felelõssége kezelni a virtuális fagráfban található grafikus objektumokat. Ezek jelenleg a kamera és a geometriákat kirajzoló objektum (\textit{camera\_node, mesh\_renderer\_node}). A rajzolás elsõ lépése, hogy összegyûjtsük a kezelni kívánt objektumokat. Ez a fagráf bejárásával történik, mely során az egyes csúcsok "feliratkozhatnak" az aktuális feldolgozási eljárásra. Az így összegyûjtött geometriai objektumok mindegyikére megtörténik a láthatósági vizsgálat, a kapott kamerák szempontjából, az oktális fa segítségével. Majd a végsõ geometria lista megjelenítésre kerül a megfelelõ rajzolási és transzformációs paraméterek beállításával.