\Chapter{Digitális tartalom nyílvántartás}
\label{Chap:tartalom}
A rendszer egy alapvetõ komponense, a tartalom nyílvántartó alrendszer. A következõkben láthatjuk mit nevezünk digitális tartalomnak, hogy milyen felelõsségei vannak egy ilyen alrendszernek és, hogy hogyan épül fel a futási környezetben használt, a tartalmat reprezentáló adatstruktúra.

\Section{A digitális tartalom definiálása}
\textit{Digitális tartalom}nak fogunk nevezni minden olyan adatot, ami közvetlenül nem szükséges a rendszer mûködéséhez, tehát a program futtatásához. Nem soroljuk ide a konfigurációs adatokat, hiszen azok általában elengedhetetlenek a program megfelelõ operálásához. Ide sorolunk minden olyan adatot, amit a rendszer a futása során valamilyen elõre leprogramozott módon feldolgoz és az így kinyert információt egy jól definiált módon felhasználja.

Ilyenek lesznek a három-dimenziós geometriai entitások, melyek adatai a futás során a grafikus kártyán kerülnek tárolásra, feldolgozásra, majd a képernyõn megjelenítésre. A textúra és shader-program adatokat, amelyeknek szintén a grafikai megjelenítésben lesz szerepük, valamint a szkript-programokat, melyek a rendszer interaktivitását hivatottak szolgálni, hasonlóképp, ilyen tartalomnak tekintünk.

Egy digitális tartalom entitás, egy logikailag összetartozó adathalmaz. A rendszer megvalósítása szempontjából, az egyszerûség kedvéért egy, a fájlrendszeren jelen levõ fájlt tekintünk egy entitásnak, mely tartalmaz minden szükséges adatot a tartalom helyes betöltéséhez és feldolgozásához.

\Section{A nyílvántartó rendszer felé támasztott követelmények}
\SubSection{Adat redundancia megelõzése}
A tartalom nyílvántartó rendszer elsõ és legfontosabb szerepe az \textit{adat redundancia} kiküszöbölése. Jelen esetben akkor beszélhetünk adat-redundanciáról, ha egy entitás, illetve az azzal asszociált fájl a szükségesnél többször kerül betöltésre a merevlemezrõl (vagy a fájlrendszer szempontjából ekvivalensnek tekinthetõ adathordozóról) a memóriába, mint azt a rendszer igényelné a helyes futás érdekében. 

Ezen követelmény teljesítéséhez a tartalom adatstruktúrának támogatnia kell a fájlokkal történõ asszociációt és az egyedi azonosítást. A fájl-asszociáció létrejöhet a fájl elérési útvonalának tárolásával, az egyedi azonosítás pedig egy tetszõleges azonosító bevezetésével. Az azonosító jelen esetben egy ember által olvasható formátum lesz, annak érdekében, hogy a késõbbiekben az adatstruktúra példány elérését is lehetõvé tegye. 

Az elsõ lépés az adat redundancia megelõzésében, a nyílvántartó rendszernek közölt adatok szûrése: a rendszert használó kód (\textit{kliens}) kérheti egy adott azonosítójú entitás betöltését. A rendszer azonban, elõszõr ellenõrzi, hogy adott azonosítóval van-e már betöltött entitás és ha igen, nem végez betöltést. Ezzel megspórolva az adat feldolgozásra szánt idõt és az entitás memóriaköltségét. A következõ lehetõség a redundancia megelõzésére akkor kap szerepet ha a kliens nem az egyedi azonosító, hanem egy fájl elérési útvonalával kérelmezi a betöltést. Ebben az esetben a rendszernek nincs lehetõsége az egyedi azonosítót ellenõrizni. 

A megoldást egy egyszerû és gyorsan futtatható \textit{hasítófüggvény} jelenti. A hasítófüggvények olyan függvények, melyek lehetõvé teszik egy változó hosszúságú bemenõ adatból (jelen esetben egy fájlból) történõ fix, az adott algoritmusra jellemzõ hosszúságú kimenetet generálni. A legelterjedtebb hasító algoritmusok közé tartoznak az SHA algoritmus család tagjai \acite{wiki_hash}. Az SHA-1 algoritmus kriptográfiai jelentõsége napjainkban csökkent, hiszen ki van téve az úgy nevezett \textit{ütközési támadások}nak \acite{sha1_collision}. Azonban ez nem befolyásolja az algoritmus kompetenciáját abban az esetben ha fájlok egyenlõségét kívánjuk vizsgálni. Ilyen célokra például a verzió követõ rendszerek is használják.

Abban az esetben tehát, ha nem áll rendelkezésre az entitást egyedileg azonosító adat, a megadott elérési útvonalon található fájlból készíthetünk egy "kivonatot" a hasító algoritmus segítségével, ami egyedi az adott fájl tartalmára vonatkozólag (ahhoz, hogy $\frac{1}{10^{18}}$ legyen a valószínûsége az ütközésnek, $1,71 * 10^{15}$ különbözõ bemeneti adattal kell dolgozni a 160 bit hosszúságú SHA-1 esetén \acite{hash_collision_probs}). A kivonattal pedig már egyszerûen ellenõrízhetjük, hogy megtalálható-e már a kért adat a memóriában. Ehhez azonban el kell tárolni az adatstruktúrában a kivonatot a késõbbi ellenõrzéshez.

További optimalizációs lehetõség, hogy minden betölteni kívánt fájl mellé egy meta-fájlt hozunk létre, melyben eltároljuk a hasító algoritmus korábbi eredményét, ezzel tovább spórolva a fájl olvasás és a hasítás erõforrás igényein. Ebben az esetben viszont ellenõriznünk kell, hogy a meta-fájlba írt kivonat helyes-e még, hiszen a fájl megváltozhat idõközben. Ehhez azonban elegendõ lehet a fájl és a meta-fájl írási idõpontjának összehasonlítása.

\SubSection{Hatékony tartalom elérés biztosítása}
\SubSection{Nem használt tartalom kisöprése}
\SubSection{Szálbiztonság megvalósítása}
\SubSection{Memória statisztika vezetése}