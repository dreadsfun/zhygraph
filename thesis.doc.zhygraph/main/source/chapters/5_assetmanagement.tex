\Chapter{Digitális tartalom nyílvántartás}
\label{Chap:tartalom}
A rendszer egy alapvetõ komponense, a tartalom nyílvántartó alrendszer. A következõkben láthatjuk mit nevezünk digitális tartalomnak, hogy milyen felelõsségei vannak egy ilyen alrendszernek és, hogy hogyan épül fel a futási környezetben használt, a tartalmat reprezentáló adatstruktúra.

\Section{A digitális tartalom definiálása}
\textit{Digitális tartalom}nak fogunk nevezni minden olyan adatot, ami közvetlenül nem szükséges a rendszer mûködéséhez, tehát a program futtatásához. Nem soroljuk ide a konfigurációs adatokat, hiszen azok általában elengedhetetlenek a program megfelelõ operálásához. Ide sorolunk minden olyan adatot, amit a rendszer a futása során valamilyen elõre leprogramozott módon feldolgoz és az így kinyert információt egy jól definiált módon felhasználja.

Ilyenek lesznek a három-dimenziós geometriai entitások, melyek adatai a futás során a grafikus kártyán kerülnek tárolásra, feldolgozásra, majd a képernyõn megjelenítésre. A textúra és shader-program adatokat, amelyeknek szintén a grafikai megjelenítésben lesz szerepük, valamint a szkript-programokat, melyek a rendszer interaktivitását hivatottak szolgálni, hasonlóképp, ilyen tartalomnak tekintünk.

Egy digitális tartalom entitás, egy logikailag összetartozó adathalmaz. A rendszer megvalósítása szempontjából, az egyszerûség kedvéért egy, a fájlrendszeren jelen levõ fájlt tekintünk egy entitásnak, mely tartalmaz minden szükséges adatot a tartalom helyes betöltéséhez és feldolgozásához.

\Section{Adat redundancia megelõzése}
A tartalom nyílvántartó rendszer elsõ és legfontosabb szerepe az \textit{adat redundancia} kiküszöbölése. Jelen esetben akkor beszélhetünk adat-redundanciáról, ha egy entitás, illetve az azzal asszociált fájl a szükségesnél többször kerül betöltésre a merevlemezrõl (vagy a fájlrendszer szempontjából ekvivalensnek tekinthetõ adathordozóról) a memóriába, mint azt a rendszer igényelné a helyes futás érdekében.

A legalapvetõbb igény a redundancia megszüntetésével kapcsolatban, hogy a tartalmat reprezentáló adatstruktúrát soha nem másoljuk le. Minden egyedi struktúra, a futási környezet szintjén is egyedi objektumot jelent a memóriában. Ha valamelyik belsõ vagy külsõ (\textit{kliens}) kódnak szüksége van egy objektumra, azok mindig konstans, vagy nem-konstans \textit{referenciákon} (pointereken) keresztül kerülnek megosztásra.

A követelmény teljesítéséhez szükséges továbbá, hogy a tartalom adatstruktúra támogassa a fájlokkal történõ asszociációt és az egyedi azonosítást. A fájl-asszociáció létrejöhet a fájl elérési útvonalának tárolásával, az egyedi azonosítás pedig egy tetszõleges azonosító bevezetésével. Az azonosító jelen esetben egy ember által olvasható formátum lesz, annak érdekében, hogy a késõbbiekben az adatstruktúra példány elérését is lehetõvé tegye.

Az elsõ lépés az adat redundancia megelõzésében, a nyílvántartó rendszernek közölt adatok szûrése: a rendszert használó kód (kliens) kérheti egy adott azonosítójú entitás betöltését. A rendszer azonban, elõszõr ellenõrzi, hogy adott azonosítóval van-e már betöltött entitás és ha igen, nem végez betöltést. Ezzel megspórolva az adat feldolgozásra szánt idõt és az entitás memóriaköltségét. A következõ lehetõség a redundancia megelõzésére akkor kap szerepet ha a kliens nem az egyedi azonosító, hanem egy fájl elérési útvonalával kérelmezi a betöltést. Ebben az esetben a rendszernek nincs lehetõsége az egyedi azonosítót ellenõrizni. 

A megoldást egy egyszerû és gyorsan futtatható \textit{hasítófüggvény} jelenti. A hasítófüggvények olyan függvények, melyek lehetõvé teszik egy változó hosszúságú bemenõ adatból (jelen esetben egy fájlból) történõ fix, az adott algoritmusra jellemzõ hosszúságú kimenetet generálni. A legelterjedtebb hasító algoritmusok közé tartoznak az SHA algoritmus család tagjai \cite{wiki_hash}. Az SHA-1 algoritmus kriptográfiai jelentõsége napjainkban csökkent, hiszen ki van téve az úgy nevezett \textit{ütközési támadások}nak \cite{sha1_collision}. Azonban ez nem befolyásolja az algoritmus kompetenciáját abban az esetben ha fájlok egyenlõségét kívánjuk vizsgálni. Ilyen célokra például a verzió követõ rendszerek is használják.

Abban az esetben tehát, ha nem áll rendelkezésre az entitást egyedileg azonosító adat, a megadott elérési útvonalon található fájlból készíthetünk egy "kivonatot" a hasító algoritmus segítségével, ami egyedi az adott fájl tartalmára vonatkozólag (ahhoz, hogy $\frac{1}{10^{18}}$ legyen a valószínûsége az ütközésnek, $1,71 * 10^{15}$ különbözõ bemeneti adattal kell dolgozni a 160 bit hosszúságú SHA-1 esetén \cite{hash_collision_probs}). A kivonattal pedig már egyszerûen ellenõrízhetjük, hogy megtalálható-e már a kért adat a memóriában. Ehhez azonban el kell tárolni az adatstruktúrában a kivonatot a késõbbi ellenõrzéshez.

További optimalizációs lehetõség, hogy minden betölteni kívánt fájl mellé egy meta-fájlt hozunk létre, melyben eltároljuk a hasító algoritmus korábbi eredményét, ezzel tovább spórolva a fájl olvasás és a hasítás erõforrás igényein. Ebben az esetben viszont ellenõriznünk kell, hogy a meta-fájlba írt kivonat helyes-e még, hiszen a fájl megváltozhat idõközben. Ehhez azonban elegendõ lehet a fájl és a meta-fájl írási idõpontjának összehasonlítása.

\Section{Hatékony tartalom elérés biztosítása}
A korábbiakban már hozzáadtunk egy egyedi azonosítót a tartalom adatstruktúrához, a kliensek fõleg ezen keresztül érhetik majd el a kívánt objektumokat. Annak érdekében, hogy az elérés sebessége megfelelõ legyen, az objektumokat összepárosítjuk az egyedi azonosítójukkal egy, úgy nevezett \textit{hasítótáblában}.

A hasítótáblák olyan, asszociatív adatstruktúrák, melyekben a kulcsok egy hasító algoritmussal kerülnek generálásra, azok pedig közvetlenül indexelik a belsõ tárolót, valamilyen, imeplementációtól függõ ütközés-kezelési stratégiával \cite{hash_table}.

A hasítótábla kulcs típusa az egyedi azonosító típusa lesz (\textit{string}), az érték típusa pedig az adatstruktúra \textit{referenciatípusa}. Mivel nincs szükség a kulcsok rendezésére, valamint általában az objektumok elérése gyakoribb lesz, mint a beillesztésük, a hasítótábla egy rendezetlen változatát választjuk, ezzel spórolva a rendezés költségét. A C++ nyelv például biztosít ilyen adatstruktúrát az \textit{std::unordered\_map<T>} osztály formájában. A rendezetlen hasítótábla elem beillesztésének és elérésének idõkomplexitása átlagos esetben: $O(1)$, legrosszabb esetben: $O(size())$, ahol size() az aktuális táblaméret \cite{unordered_map}.

\Section{Nem használt tartalom kisöprése}
Annak érdekében, hogy a rendszer memóriafoglalását egy bizonyos szint alatt tartsuk, illetve, hogy feleslegesen ne tartsunk fent foglalást, azokat az objektumokat, amelyekre nincsen hivatkozás egy szemétgyûjtõ listára fogjuk helyezni. A szemétgyûjtõ listáról pedig bizonyos idõközönként egy algoritmus kiválasztja azokat az objektumokat, melyek erõforrásai felszabadításra kerülnek. 

Ehhez szükséges az objektumokra aktívan jelen levõ \textit{referenciák} (hivatkozások) számontartása. Ezt egy "csomagoló" osztállyal érjük el, aminek egyetlen szerepe van: az általa hivatkozott tartalom objektumra jelenlevõ referenciák számlálása. A csomagoló osztály - az adatstruktúránkkal ellentétben - másolható, ez teszi lehetõvé, hogy az alrendszeren kívül, vagy az alrendszeren belül különbözõ kódrészek úgy osszák meg az adott objektumot, hogy azt nem másolják le, viszont a referenciák számát mindig számontartsuk. 

Ugyan biztosít hasonló struktúrát a C++ környezet a \textit{std::shared\_ptr<T>} osztály formájában, ennek elsõdleges feladata a referenciaszámláló nullára csökkenéskor történõ automatikus és azonnali meghívása az úgy nevezett \textit{callable, deleter} objektumnak. Az alap mûködési mechanizmus értelmében, ennek következménye, hogy a menedzselt objektum memóriája (a \textit{destruktor} hívása után) egyszerûen felszabadul \cite{shared_ptr}. Jelen esetben, azonban nem szeretnénk ha a az objektum azonnal megszûnne, amikor a referenciák száma nullára csökken. Ehelyett, a nyílvántartó rendszer értesítést kap arról, hogy egy objektumra már nincsen hivatkozás, ezzel lehetõséget adva neki, hogy egy szemétgyûjtõ listára helyezze azt. 

Ennek az indirekciónak akkor van jelentõsége, amikor egy kliens kód nem sokáig tart fent referenciákat az általa használt objektumokra, viszont gyakran kívánja elérni õket. Ez azt eredményezheti, hogy egy adott objektum referenciaszámlálója hamar nullára csökken, viszont rövidesen ezután a kliens ismét el akarja érni az objektumot. Ha az objektumok kisöprése azonnali lenne, az aktuális lekérés egy ismételt betöltést és feldolgozást jelentene. Azonban ha az objektum még megtalálható a szemétgyûjtõ listán egy bizonyos ideig, akkor onnan ismét a referált objektumok listájába léphet. Természetesen ezzel nem szûrhetõ ki az összes \textit{"cache-miss"} (azon esetek, amikor egy kért adat nem található meg a gyors elérésû tárolóban, ezért egy lassabb eljárással kell betölteni), de jelentõsen csökkenthetõ a számuk.

A szemétgyûjtõ listáról egy aszinkron eljárás szabadítja fel a kiválasztott objektumokat, a következõ algoritmus szerint:
Az eljárás elsõ lépésként ellenõrzi, hogy a maximális (konfigurálható) memóriahasználatot túllépi-e az alrendszer által, digitális tartalomnak allokált memóriafoglalás. Ha nem akkor az eljárás azonnal visszatér, hiszen ha nincs szükség a memória felszabadítására, akkor az az érdekünk, hogy minél több objektum maradjon betöltve. Ha a memória limitet meghaladja a foglalás, akkor szintén egy konfigurálható paraméter dönti el a következõ lépést:

\begin{itemize}
\item A \textit{"Legkevesebb felszabadított objektum"} elnevezésû eljárási mód lényege, hogy arra törekedjen az algoritmus, hogy a lehetõ legkevesebb objektum felszabadításával elégítse ki a memóriafoglalási követelményeket. Ebbõl egyenesen következik, hogy mindig a legnagyobb memóriafoglalású objektumokat fogja felszabadítani elsõként. Optimalizációs lehetõség, hogy a listán lévõ objektumok, memóriafoglalás alapján történõ rendezése \textbf{elõtt}, megvizsgáljuk, hogy lehetséges-e egyáltalán kellõ mennyiségû memóriát felszabadítani a listán található objektumok kisöprésével. Hiszen, például ha a listán lévõ objektumok mindegyikének felszabadításával sem elégítjük ki a memória követelményeket, akkor errõforrást pazarlunk egy esetleges rendezéssel, melynek végeredménye egyébként is az összes objektum felszabadítása lenne.
\item A \textit{"Legnagyobb megtartott objektumok"} elnevezésû eljárási mód lényege, hogy arra törekedjen az algoritmus, hogy a lehetõ legnagyobb objektumokat hagyja betöltve, hiszen azok újratöltési ideje valószínûleg nagyobb mint a kis helyet foglaló objektumoké. Ebbõl következik, hogy minél több és kisebb objektumok kisöprése lesz a cél. Az elõzõ eljárási módban leírt optimalizációs lehetõség alkalmazható ezen esetben is.
\end{itemize}

A két eljárási mód közötti döntés, annak a mérlegelését követeli, hogy egy adott implementációval sok, kisebb objektum vagy pedig kevés, nagyobb objektum be- illetve "kitöltése" a hatékonyabb. A mérési eredményekkel betekintést nyerhetünk ebbe a problémába a \textit{"Futtatási tesztek és mérési eredmények"} címû fejezetben.

\Section{Szálbiztonság megvalósítása}
A tartalom nyílvántartó rendszer terve törekszik a párhuzamosítási lehetõségek kihasználására. Láthattuk például, hogy a szemétgyûjtõ listáról történõ felszabadítás is egy külön szálon történik. Ezen kívül szeretnénk ha a tartalmak betöltése is megvalósulhatna aszinkron módon, annak érdekében, hogy egy esetlegesen idõigényes töltési folyamat ne akadályozza a rendszer más eljárásait. A párhuzamosítás az elõnyeivel együtt, hordoz magában bizonyos veszélyeket, a hibák megelõzésének lehetõségeit tárgyaljuk ebben a fejezetben.

A \textit{memória versengés} azt a problémát írja le, amikor egy megoszott memóriaterületet akar elérni valós idõben, \textbf{párhuzamosan}, két különbözõ, egymástól független futási egység (jelen esetben \textit{szálak}).

A memória versengés problémájának ki van téve a tartalom objektum \textit{állapot leíró változó}ja, hiszen egy szál ha el akarja érni az adott objektumot, az ellenõrizni fogja, hogy az állapota \textit{"betöltött"}-e, és ha nem akkor betöltést fog kezdeményezni. Eközben természetesen elõfordulhat, hogy egy másik szál már éppen a betöltést végzi. Ilyenkor van esély rá, hogy amikor az ellenõrzést végzõ szál lekérdezi az objektum állapotát akkor még \textit{"betöltetlen"}-t lát, viszont egy másik szál már elkezdte az objektum betöltését, azonban még nem állította át az állapotot \textit{"betöltés alatt"}-ra. Ekkor a második szál is el fogja kezdeni az objektum betöltését, ezzel további, specifikálatlan viselkedést produkálva a programban.

Egy primitív változó (nem összetett, több primitívbõl álló kompozit) védelme megoldható az úgy nevezett atomi struktúrával. A C++ környezet ezt az \textit{std::atomic<T>} osztály formájában biztosítja. Egy atomi mûvelet azt jelenti ebben az esetben, hogy ha egy szál értéket ad a változónak, miközben egy másik szál olvassa azt, a viselkedés, tehát a mûveletek sorrendje, jól definiált \cite{atomic}.

A többi komplex struktúra, mint például a tartalom eléréshez használt hasítótábla megvédhetõ a kölcsönös kizárást megvalósító struktúrákkal. A C++ esetén ezt az \textit{std::mutex} osztály foglalja magába, mely a következõ birtoklási szemantikát biztosítja:

\begin{itemize}
\item Egy hívó szál birtokolja a \textit{mutex} objektumot attól a pillanattól fogva, hogy sikeresen meghívta a \textit{"lock"} vagy \textit{"try\_lock"} függvények valamelyikét, egészen addig míg meg nem hívja az \textit{"unlock"} függvényt.
\item Amíg egy szál birtokolja a \textit{mutex} objektumot, minden más szál blokkolódik (a \textit{"lock"} hívás esetén), vagy hamis visszatérési értéket kap (a \textit{"try\_lock"} hívás esetén) ha megpróbálják birtokba venni a \textit{mutex} objektumot.
\item Egy hívó szál nem birtokolhatja a \textit{mutex} objektumot mielõtt, meghívná a \textit{"lock"} vagy \textit{"try\_lock"} valamelyikét \cite{mutex}.
\end{itemize}

\Section{Memória statisztika vezetése}
Annak érdekében, hogy a rendszer kielégíthesse a memóriafoglalási követelményeket illetve, hogy mérési adatokkal szolgálhasson a futtatási tesztek során, memória statisztikát szükséges vezetnie.

A nyílvántartó alrendszer által foglalt memória a következõ értékekbõl tevõdik össze:
\begin{itemize}
\item A nyílvántartó alrendszer \textbf{objektum} által közvetlenül foglalt memória mérete. Ebbe beletartozik minden adattag, számláló és a használt referenciák méretei is. Függ attól, hogy hány különbözõ objektumról van nyílvántartás, hiszen a hasítótáblába belekerül az objektum egyedi azonosítója, illetve a referenciák is foglalnak egy bizonyos méretû memóriát.
\item A létrehozott tartalom objektumok mérete. Ide tartozik minden adattag, amit a korábbi fejezetekben bevezettünk az adatstruktúrába: az egyedi azonosító, a fájl elérési útvonala és a 160 bites szignatúra. Valamint további, itt nem említett adattagok. Ez a méret nem kifejezetten változékony, egy fájl elérési útvonalára jellemzõen operációs rendszeri limit van, az egyedi azonosítóról feltételeztük, hogy ember által olvasható, tehát a hossza kényelmi okokból, \textit{"szubjektívan limitált"}. A szignatúra hossza pedig minden esetben állandó.
\item A létrehozott tartalom objektumok által tárolt, valós digitális-tartalom mérete. A programtól független adat méretek, például különbözõ felbontású textúrák esetén, széles intervallumon változhat a szükséges memória. Ide tartozik a három-dimenziós geometriai alakzatok csúcspont leíró adatai, koordináták, normál-vektorok értékei is.
\end{itemize}

Ezeket az adatokat külön-külön, és összesítve is tudnia kell szolgáltatni a rendszernek, annak érdekében, hogy pontos képet kapjunk az alkalmazás memória aktivitásáról, illetve az alkalmazott algoritmusok memória hatékonyságáról.