\Chapter{Python beágyazása a C++ környezetbe}

Ebben a fejezetben láthatjuk, hogy milyen problémák merülhetnek fel egy konkrét szkript nyelv, C++ környezetbe ágyazása során, és hogyan lehet azokat minél elegánsabb technikákkal megoldani. Alapvetõen két dolgot szeretnénk elérni: hogy már meglévõ, natív funkcionalitást használhassunk fel a Python kódból, illetve, hogy a Python-ban elõre definiált függvényeket hívhassunk meg C++-ból.

\Section{A Python szkriptnyelv}

A Python egy széles körben elterjedt, magas szintû, általános célú programozási nyelv. A Python interpretált és dinamikusan tipizált környezete, azzal a céllal lett kialakítva, hogy minél olvashatóbb és minél kevesebb kóddal váljon lehetségessé kis és nagy alkalmazások készítése egyaránt. A nyelvnek automatikus memória kezelõ rendszere van és támogat különbözõ programozási paradigmákat, mint az objektum-orientált, imperatív vagy funkcionális programozás. A Python referencia implementációja a \textit{CPython} egy nyílt forráskódú szoftver \cite{python}.

Mindezen tulajdonságok tökéletesen alkalmassá teszik a nyelvet, ahhoz, hogy a rigid, natív C++ környezetbe ágyazva, növeljük az alkalmazás rugalmasságát és skálázhatóságát. Az objektum-orientált paradigma támogatottsága lehetõvé teszi, hogy a C++ környezetben bevezetett stuktúrákkal ekvivalenseket hozzunk létre, ezzel jól átláthatóvá téve a funkcionális és adatkapcsolatot a nyelvek között. A nyelv interpretált jellege kiküszöböli a C++ fordítási és linkelési idejébõl származó korlátozásokat. Az automatikus memória kezelés pedig csökkenti a hibalehetõségeket és lehetõvé teszi, hogy a lehetõ legtöbb idõt fordítsunk az alkalmazáslogika kialakítására.

\Section{C/C++ hívása Python-ból}

\SubSection{Alacsony szintû kiterjesztés}

A Python környezet, más szkriptnyelvekhez hasonlóan biztosítja a lehetõséget, hogy a meglévõ, alap funkcionalitását kiterjesszük, saját C, vagy C++-ban írt funkciókkal. Ez azt jelenti, hogy készíthetünk olyan C funkciókat, amik a Python funkciókhoz hasonló hívási és visszatérési szemantikával rendelkeznek. Ennek elõnye, hogy a Python-ból történõ hívás egyszerû és letisztult lesz. Hátránya viszont, hogy ekkor a natív oldali kód lesz bonyolultabb és kevésbé olvasható.

Például, tegyük fel, hogy a C könyvtár egy beépített funkcióját a \textit{system()} hívást akarjuk elérhetõvé tenni a Python számára. Azt szeretnénk, hogy a következõ módon legyen hívható a funkció:

\begin{python}
import exmpl
status = exmpl.system("ls -l")
\end{python}

Elsõ lépésként létrehozunk egy forrás fájlt \textit{exmplmodule.c} névvel, aminek a tartalma a következõ lesz:

\begin{cpp}
#include <Python.h>

static PyObject* 
exmpl_system(PyObject* self, PyObject* args) {
    const char* command;
    int sts;

    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;
    sts = system(command);
    return Py_BuildValue("i", sts);
}
\end{cpp}

Az ilyen formában kialakított funkcióknak a C/C++ oldalon mindig két paramétere van: a \textit{self} és az \textit{args}. A self paraméter a Pythonban (és egyéb objektum-orientált nyelvekben) azon objektumot jelenti, amire a funkcióhívás történt (implicit \textit{this pointer} a C++ nyelvben). Ez jelen esetben \textit{NULL} lesz, hiszen a funkció modul- és nem objektumszintû. Az args paraméter egy kompozit objektum, ez tárolja a funkciónak átadott minden egyéb paramétert. 

A Python nyelvben minden objektum közös õstípusa a \textit{PyObject}, legyen szó primitív értékekrõl vagy osztálypéldányokról. Így tehát az args változóban tárolt objektumok is mind PyObject típusúak, ezért használat elõtt konverzió szükséges a megfelelõ típusra. A kódrészletben látható \textit{PyArg\_ParseTuple} hívás feldolgozza a paraméterül kapott argumentum objektumot, ellenõrzi a paraméterek típusát és a megadott formátum alapján eltárolja az értéküket a kívánt memória címre.

A PyArg\_ParseTuple igaz értékkel tér vissza ha minden értéknek megfelelõ volt a típusa és sikeresen beírta az értéküket a megadott címekre. Hamis értékkel pedig akkor tér vissza, ha valamilyen nem megfelelõ argumentum listát kapott vagy a megadott formátum nem megfelelõ. \cite{extendpython}

A következõ lépésben létrehozzuk a modul, funkció tábláját és az inicializációs függvényét. Ahhoz, hogy a system funkciót meghívhassuk Pythonból, regisztrálnunk kell azt, a modul funkció táblájában:

\begin{cpp}
static PyMethodDef ExmplMethods[] = {
    // ...
    {"system",  exmpl_system, METH_VARARGS, "Execute a shell command."},
    // ...
    {NULL, NULL, 0, NULL}        /* Sentinel */
};
\end{cpp}

Ezután létrehozzuk a modult leíró struktúrát, amiben hivatkozunk az elõzõ funkciótáblára:

\begin{cpp}
static struct PyModuleDef exmplmodule = {
	PyModuleDef_HEAD_INIT,
	"exmpl", /* name of module */
	exmpl_doc, /* module documentation, may be NULL */
	-1, /* size of per-interpreter state of the module,
	or -1 if the module keeps state in global variables.*/
	ExmplMethods
};
\end{cpp}

Végül ezt a struktúrát kapja meg a modult létrehozó funkció, amikor a modul betöltésre kerül az interpreter által:

\begin{cpp}
PyMODINIT_FUNC
PyInit_exmpl(void) {
    return PyModule_Create(&exmplmodule);
}
\end{cpp}

Amikor egy Python program elsõként importálja a modult, ez a funkció kerül meghívásra. A funkció létrehozza a modult, és elhelyezi benne a funkciótáblában regisztrált függvényeket, amik ezután használhatóvá válnak.

Ha a Python környezetet beágyazva inicializáljuk, a modul létrehozása nem történik meg automatikusan. Ahhoz, hogy ez megtörténjen, a modult hozzá kell adnunk az inicializációs táblához:

\begin{cpp}
int
main(int argc, char *argv[]) {
    wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, 
                "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }

    /* Add a built-in module, before Py_Initialize */
    PyImport_AppendInittab("exmpl", PyInit_exmpl);

    /* Pass argv[0] to the Python interpreter */
    Py_SetProgramName(program);

    /* Initialize the Python interpreter.  Required. */
    Py_Initialize();

    /* Optionally import the module; alternatively,
       import can be deferred until the embedded script
       imports it. */
    PyImport_ImportModule("exmpl");

    // ...

    PyMem_RawFree(program);
    return 0;
}
\end{cpp}

Ahogy feltettük korábban, ennek a megközelítésnek a hátránya, hogy a C kód kevésbé olvasható. Láthatóan a paraméterek felhasználása Python objektumokon keresztül történik, illetve egyéb Python specifikus hívást is kell tennünk a megfelelõ mûködés érdekében \cite{extendpython}. Nézzük meg, hogy milyen további lehetõségek állnak rendelkezésünkre a Python beágyazását illetõen.

\SubSection{Dinamikusan linkelt könyvtár és a ctypes}

\begin{figure}[ht]
\centering
\epsfig{file=chapters/content/ctypes.eps, width=14.41cm, height=10.516cm}
\caption{A ctypes által biztosított típusok}
\label{fig:ctypes}
\end{figure}

A \textit{ctypes} egy külsõ, funkció könyvtár, ami lehetõvé teszi, hogy natív, dinamikus vagy megosztott könyvtárak funkcióit hívjuk Pythonból, C kompatibils adat típusokkal.

A ctypes egy modulja a cdll, ami lehetõvé teszi, hogy tetszõleges dinamikus könyvtárakat töltsünk be az alkalmazás címterébe, Pythonon keresztül. Használata a következõ:

\begin{python}
from ctypes import *
lib = cdll.LoadLibrary('cAPI.dll')
\end{python}

A \textit{LoadLibrary} hívás eredménye egy DLL objektum, amin keresztül, innentõl kezdve elérhetõek a könyvtár exportált funkciói, amennyiben sikeres volt a betöltés.

A \textit{cAPI.dll} könyvtárat úgy kell létrehoznunk, hogy a használni kívánt funkciók a C hívási szemantikát kövessék. Ezek alapján egy példa C funkció, amit Pythonból is hívhatunk a következõ képpen alakul:

\begin{cpp}
CAPI_SHARED int log_debug( const char* msg ) {
    return capi_bridge::instance->m_logger->
        log( 
            priority::debug, 
            msg, 
            "capi_bridge" 
        );
}
\end{cpp}

Láthatjuk, hogy az elõzõ részben tárgyalt módszerrel ellentétben, most nincs szükség a Python specifikus paraméterátadási és visszatérési módszerekre. A funkció kényelmesen használható továbbra is, mint bármely másik C funkció. Láthatjuk továbbá, hogy kizárólag a hívási szemantikának kell C specifikusnak lennie, maga a függvény implementációja már tartalmazhat tetszõleges C++ kódot is, ezzel kiteljesítve a Python-C-C++ kapcsolatot.

A \textit{CAPI\_SHARED} kifejezés csupán arra szolgál, hogy a Visual C++ környezetben megjelöljük a funkciót, mint exportálni kívánt funkció. Ez szükséges ahhoz, hogy a könyvtár betöltése után elérhetõvé váljon. A kifejezés a következõ képpen van definiálva:

\begin{cpp}
#ifndef CAPI_SHARED
#  ifdef CAPI_EXPORTS
#    define CAPI_SHARED __declspec(dllexport)
#  else
#    define CAPI_SHARED __declspec(dllimport)
#  endif // ~CAPI_EXPORTS
#endif // ~CAPI_SHARED
\end{cpp}

A Python nyelv oldalán, annyi lehet a felelõsségünk, hogy biztosítsuk az felhasznált natív funkciók típusbiztonságát. Erre a ctypes azt a lehetõséget biztosítja, hogy felsoroljuk a funkciók visszatérési értékének és paramétereinek a típusát. Ez gyakorlatilag egy leegyszerûsített módja a függvényszignatúra definiálásának:

\begin{python}
lib.log_debug.argtypes = [c_char_p]
lib.log_debug.restype = c_int
\end{python}

A \textit{c\_char\_p} megfelelõje a karakter pointer (\textit{char*}) a C oldalon, a \textit{c\_int} típusé pedig az \textit{int}. Ezen, ctypes-ban definiált kifejezések biztosítják a kompatibilitást a C és és Python nyelvek típusai között. Az összes elérhetõ típus látható a \myref{fig:ctypes} ábrán.

Ezek után a funkció egyszerûen hívható Pythonból a következõ képpen:

\begin{python}
lib.log_debug('log test')
\end{python}

\Section{Python hívása C++-ból}

Az elõzõekben láthattuk, hogyan érhetünk el meglévõ C/C++ funckiókat Python-ból. Ennek a lehetõségnek az elõnyeit már ismerjük: nagy teljesítményû natív kód futtatását tesszük lehetõvé, egy rugalmas és letisztult környezetbõl. 

A beágyazás következõ lépése, hogy felcseréljük a két nyelv szerepét és most Python funkciókat hívjunk meg C++-ból. Erre azért van szükség mert szeretnénk elõre definiált függvényszignatúrákat definiálni, amikhez bizonyos funkciókat kötünk. Ilyen lesz például egy szkript frissítési funkciója: az alkalmazás frissítési köre a C++ oldalon található, azonban szeretnénk ha a szkriptek is reagálhatnának erre az \textit{eseményre}.

A cél tehát, hogy elõre meghatározzunk bizonyos pontokat a natív kód futásában, ahol lehetõséget adunk a szkriptek futtatására. Tipikus példa erre a korábban már ismertetett játék motor, a \textit{Unity3D} megoldása, a \textit{MonoBehaviour.Update()}. Ez a funkció képfrissítésenként egyszer hívódik meg minden szkriptben ahol engedélyezve van éa jellemzõen itt implementálják a szkriptek a játéklogika jelentõs részét \cite{monoupdate}.

Meghívhatunk Python funkciót C++-ból a \textit{PyRun\_SimpleString("update()")} segítségével. Ez azonban nem hatékony, hiszen ebben az esetben az interpreter minden híváskor feldolgozza és lefordítja a szkript szöveget. Egy sokkal hatékonyabb megoldás, ha közvetlenül a függvény objektumra vonatkozó referenciát kérünk el a Python környezettõl és azt használjuk a hívás végrehajtásához.

A Python minden globálisan definiált függvényt, a környezet globális táblájában tárol. Így tehát, ha el tudjuk érni a globális táblát, akkor bármely ott definiált funkciót is használhatjuk. A Python környezet biztosít funkciókatt a globális tábla eléréséhez:

\begin{cpp}
#include <Python.h>

void process_expression(int num, char* func_name)
{
    FILE*        exp_file;
    PyObject*    main_module, * global_dict, * expression;

    // Initialize a global variable for
    // display of expression results
    PyRun_SimpleString("x = 0");

    // Open and execute the Python file
    exp_file = fopen(exp, "r");
    PyRun_SimpleFile(exp_file, exp);

    // Get a reference to the main module
    // and global dictionary
    main_module = PyImport_AddModule("__main__");
    global_dict = PyModule_GetDict(main_module);

    // Extract a reference to the function "func_name"
    // from the global dictionary
    expression =
        PyDict_GetItemString(global_dict, func_name);

    while(num--) {
        // Make a call to the function referenced
        // by "expression"
        PyObject_CallObject(expression, NULL);
    }
    PyRun_SimpleString("print x");
}
\end{cpp}

Elsõ lépésben az eljárás elkér egy referenciát a fõmodulra, a 
\begin{cpp}
PyImport_AddModule("__main__")
\end{cpp}
 hívással. Ezután a 
\begin{cpp}
PyModule_GetDict(main_module)
\end{cpp} 
már a globális táblát adja vissza, ami a keresett függvényt tartalmazza. Így a függvény eléréséhez már csak a 
\begin{cpp}
PyDict_GetItemString(global_dict, func_name)
\end{cpp}
hívás szükséges, ahol a \textit{func\_name} a függvény neve (jelen esetben \textit{update}). 

Az utolsó lépés, hogy a
\begin{cpp}
PyObject_CallObject(expression, NULL)
\end{cpp}
függvénnyel meghívjuk a kívánt funkciót. Ennek a hívásnak az elsõ paramétere maga a függvény objektum, ami már egy betöltött és lefordított funkció a Python környezetben így ennek ismételt hívása nem jelent plusz teljesítmény költséget. 

Az utolsó kérdés a Python függvény meghívásával kapcsolatban, a paraméterek átadása. A \textit{CallObject} hívás második paramétere egy \textit{PyObject*} típusú változó, ahova egy változó elemszámú kompozit objektumot vár a függvény, aminek az elemeit végül a meghívni kívánt funkció kapja meg paraméterként. Ezen módja a paraméter átadásnak nagy fokú rugalmasságot enged meg, hiszen tetszõleges számú és típusú paramétert adhatunk át a függvénynek. Hátránya, hogy némi plusz teljesítmény költség merül fel, valamint a kompozit létrehozása nem minden esetben triviális.

Jelen esetben arról beszélünk, hogy egy elõre meghatározott szignatúrájú függvényt szeretnénk meghívni. Ez azt jelenti, hogy a CallObject által nyújtott rugalmasságról lemondhatunk. A \textit{PyObject\_CallFunction(exp, format, [values])} funkció meghívja a megadott függvényt, úgy, hogy a \textit{format} karakterlánc típusú változóban felsorolt karaktereknek megfelelõ változókat vár, a \textit{values}, változó paraméterszámú argumentumba. Például, ha a $format="sii"$, akkor a \textit{values} helyére egy karakterlánc (\textbf{s}tring), és két egész szám (\textbf{i}nteger) értéket várunk \cite{callpython}.