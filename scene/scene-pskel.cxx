// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include "scene-pskel.hxx"

// vec3_type_pskel
//

void vec3_type_pskel::
x_parser (::xml_schema::float_pskel& p)
{
  this->x_parser_ = &p;
}

void vec3_type_pskel::
y_parser (::xml_schema::float_pskel& p)
{
  this->y_parser_ = &p;
}

void vec3_type_pskel::
z_parser (::xml_schema::float_pskel& p)
{
  this->z_parser_ = &p;
}

void vec3_type_pskel::
parsers (::xml_schema::float_pskel& x,
         ::xml_schema::float_pskel& y,
         ::xml_schema::float_pskel& z)
{
  this->x_parser_ = &x;
  this->y_parser_ = &y;
  this->z_parser_ = &z;
}

vec3_type_pskel::
vec3_type_pskel ()
: vec3_type_impl_ (0),
  x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

vec3_type_pskel::
vec3_type_pskel (vec3_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  vec3_type_impl_ (impl),
  x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// vec4_type_pskel
//

void vec4_type_pskel::
x_parser (::xml_schema::float_pskel& p)
{
  this->x_parser_ = &p;
}

void vec4_type_pskel::
y_parser (::xml_schema::float_pskel& p)
{
  this->y_parser_ = &p;
}

void vec4_type_pskel::
z_parser (::xml_schema::float_pskel& p)
{
  this->z_parser_ = &p;
}

void vec4_type_pskel::
w_parser (::xml_schema::float_pskel& p)
{
  this->w_parser_ = &p;
}

void vec4_type_pskel::
parsers (::xml_schema::float_pskel& x,
         ::xml_schema::float_pskel& y,
         ::xml_schema::float_pskel& z,
         ::xml_schema::float_pskel& w)
{
  this->x_parser_ = &x;
  this->y_parser_ = &y;
  this->z_parser_ = &z;
  this->w_parser_ = &w;
}

vec4_type_pskel::
vec4_type_pskel ()
: vec4_type_impl_ (0),
  x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  w_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

vec4_type_pskel::
vec4_type_pskel (vec4_type_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  vec4_type_impl_ (impl),
  x_parser_ (0),
  y_parser_ (0),
  z_parser_ (0),
  w_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// scene_graph_pskel
//

void scene_graph_pskel::
nodes_parser (::nodes_pskel& p)
{
  this->nodes_parser_ = &p;
}

void scene_graph_pskel::
scenes_parser (::scenes_pskel& p)
{
  this->scenes_parser_ = &p;
}

void scene_graph_pskel::
parsers (::nodes_pskel& nodes,
         ::scenes_pskel& scenes)
{
  this->nodes_parser_ = &nodes;
  this->scenes_parser_ = &scenes;
}

scene_graph_pskel::
scene_graph_pskel ()
: scene_graph_impl_ (0),
  nodes_parser_ (0),
  scenes_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

scene_graph_pskel::
scene_graph_pskel (scene_graph_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  scene_graph_impl_ (impl),
  nodes_parser_ (0),
  scenes_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// nodes_pskel
//

void nodes_pskel::
node_parser (::node_pskel& p)
{
  this->node_parser_ = &p;
}

void nodes_pskel::
parsers (::node_pskel& node)
{
  this->node_parser_ = &node;
}

nodes_pskel::
nodes_pskel ()
: nodes_impl_ (0),
  node_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

nodes_pskel::
nodes_pskel (nodes_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  nodes_impl_ (impl),
  node_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// scene_pskel
//

void scene_pskel::
name_parser (::xml_schema::token_pskel& p)
{
  this->name_parser_ = &p;
}

void scene_pskel::
graph_parser (::xml_schema::string_pskel& p)
{
  this->graph_parser_ = &p;
}

void scene_pskel::
parsers (::xml_schema::token_pskel& name,
         ::xml_schema::string_pskel& graph)
{
  this->name_parser_ = &name;
  this->graph_parser_ = &graph;
}

scene_pskel::
scene_pskel ()
: scene_impl_ (0),
  name_parser_ (0),
  graph_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

scene_pskel::
scene_pskel (scene_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  scene_impl_ (impl),
  name_parser_ (0),
  graph_parser_ (0),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

// scenes_pskel
//

void scenes_pskel::
scene_parser (::scene_pskel& p)
{
  this->scene_parser_ = &p;
}

void scenes_pskel::
parsers (::scene_pskel& scene)
{
  this->scene_parser_ = &scene;
}

scenes_pskel::
scenes_pskel ()
: scenes_impl_ (0),
  scene_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

scenes_pskel::
scenes_pskel (scenes_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  scenes_impl_ (impl),
  scene_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// attribute_pskel
//

void attribute_pskel::
name_parser (::xml_schema::token_pskel& p)
{
  this->name_parser_ = &p;
}

void attribute_pskel::
value_parser (::xml_schema::string_pskel& p)
{
  this->value_parser_ = &p;
}

void attribute_pskel::
parsers (::xml_schema::token_pskel& name,
         ::xml_schema::string_pskel& value)
{
  this->name_parser_ = &name;
  this->value_parser_ = &value;
}

attribute_pskel::
attribute_pskel ()
: attribute_impl_ (0),
  name_parser_ (0),
  value_parser_ (0)
{
}

attribute_pskel::
attribute_pskel (attribute_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  attribute_impl_ (impl),
  name_parser_ (0),
  value_parser_ (0)
{
}

// node_pskel
//

void node_pskel::
name_parser (::xml_schema::token_pskel& p)
{
  this->name_parser_ = &p;
}

void node_pskel::
class__parser (::xml_schema::token_pskel& p)
{
  this->class__parser_ = &p;
}

void node_pskel::
position_parser (::vec3_type_pskel& p)
{
  this->position_parser_ = &p;
}

void node_pskel::
rotation_parser (::vec4_type_pskel& p)
{
  this->rotation_parser_ = &p;
}

void node_pskel::
scale_parser (::vec3_type_pskel& p)
{
  this->scale_parser_ = &p;
}

void node_pskel::
attribute_parser (::attribute_pskel& p)
{
  this->attribute_parser_ = &p;
}

void node_pskel::
parsers (::xml_schema::token_pskel& name,
         ::xml_schema::token_pskel& class_,
         ::vec3_type_pskel& position,
         ::vec4_type_pskel& rotation,
         ::vec3_type_pskel& scale,
         ::attribute_pskel& attribute)
{
  this->name_parser_ = &name;
  this->class__parser_ = &class_;
  this->position_parser_ = &position;
  this->rotation_parser_ = &rotation;
  this->scale_parser_ = &scale;
  this->attribute_parser_ = &attribute;
}

node_pskel::
node_pskel ()
: node_impl_ (0),
  name_parser_ (0),
  class__parser_ (0),
  position_parser_ (0),
  rotation_parser_ (0),
  scale_parser_ (0),
  attribute_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

node_pskel::
node_pskel (node_pskel* impl, void*)
: ::xsde::cxx::parser::validating::complex_content (impl, 0),
  node_impl_ (impl),
  name_parser_ (0),
  class__parser_ (0),
  position_parser_ (0),
  rotation_parser_ (0),
  scale_parser_ (0),
  attribute_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_),
  v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
{
}

#include <assert.h>

// vec3_type_pskel
//

void vec3_type_pskel::
x (float x)
{
  if (this->vec3_type_impl_)
    this->vec3_type_impl_->x (x);
}

void vec3_type_pskel::
y (float x)
{
  if (this->vec3_type_impl_)
    this->vec3_type_impl_->y (x);
}

void vec3_type_pskel::
z (float x)
{
  if (this->vec3_type_impl_)
    this->vec3_type_impl_->z (x);
}

void vec3_type_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->x_parser_)
    this->x_parser_->_reset ();

  if (this->y_parser_)
    this->y_parser_->_reset ();

  if (this->z_parser_)
    this->z_parser_->_reset ();
}

// vec4_type_pskel
//

void vec4_type_pskel::
x (float x)
{
  if (this->vec4_type_impl_)
    this->vec4_type_impl_->x (x);
}

void vec4_type_pskel::
y (float x)
{
  if (this->vec4_type_impl_)
    this->vec4_type_impl_->y (x);
}

void vec4_type_pskel::
z (float x)
{
  if (this->vec4_type_impl_)
    this->vec4_type_impl_->z (x);
}

void vec4_type_pskel::
w (float x)
{
  if (this->vec4_type_impl_)
    this->vec4_type_impl_->w (x);
}

void vec4_type_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->x_parser_)
    this->x_parser_->_reset ();

  if (this->y_parser_)
    this->y_parser_->_reset ();

  if (this->z_parser_)
    this->z_parser_->_reset ();

  if (this->w_parser_)
    this->w_parser_->_reset ();
}

// scene_graph_pskel
//

void scene_graph_pskel::
nodes (::nodes* x)
{
  if (this->scene_graph_impl_)
    this->scene_graph_impl_->nodes (x);
}

void scene_graph_pskel::
scenes (::scenes* x)
{
  if (this->scene_graph_impl_)
    this->scene_graph_impl_->scenes (x);
}

void scene_graph_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->nodes_parser_)
    this->nodes_parser_->_reset ();

  if (this->scenes_parser_)
    this->scenes_parser_->_reset ();

  this->resetting_ = false;
}

// nodes_pskel
//

void nodes_pskel::
node (::node* x)
{
  if (this->nodes_impl_)
    this->nodes_impl_->node (x);
}

void nodes_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->node_parser_)
    this->node_parser_->_reset ();

  this->resetting_ = false;
}

// scene_pskel
//

void scene_pskel::
name (const ::std::string& x)
{
  if (this->scene_impl_)
    this->scene_impl_->name (x);
}

void scene_pskel::
graph (const ::std::string& x)
{
  if (this->scene_impl_)
    this->scene_impl_->graph (x);
}

void scene_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_attr_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->graph_parser_)
    this->graph_parser_->_reset ();
}

// scenes_pskel
//

void scenes_pskel::
scene (const ::scene& x)
{
  if (this->scenes_impl_)
    this->scenes_impl_->scene (x);
}

void scenes_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->resetting_ = true;

  if (this->scene_parser_)
    this->scene_parser_->_reset ();

  this->resetting_ = false;
}

// attribute_pskel
//

void attribute_pskel::
name (const ::std::string& x)
{
  if (this->attribute_impl_)
    this->attribute_impl_->name (x);
}

void attribute_pskel::
value (const ::std::string& x)
{
  if (this->attribute_impl_)
    this->attribute_impl_->value (x);
}

void attribute_pskel::
_reset ()
{
  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->value_parser_)
    this->value_parser_->_reset ();
}

// node_pskel
//

void node_pskel::
name (const ::std::string& x)
{
  if (this->node_impl_)
    this->node_impl_->name (x);
}

void node_pskel::
class_ (const ::std::string& x)
{
  if (this->node_impl_)
    this->node_impl_->class_ (x);
}

void node_pskel::
position (const ::vec3_type& x)
{
  if (this->node_impl_)
    this->node_impl_->position (x);
}

void node_pskel::
rotation (const ::vec4_type& x)
{
  if (this->node_impl_)
    this->node_impl_->rotation (x);
}

void node_pskel::
scale (const ::vec3_type& x)
{
  if (this->node_impl_)
    this->node_impl_->scale (x);
}

void node_pskel::
attribute (const ::attribute& x)
{
  if (this->node_impl_)
    this->node_impl_->attribute (x);
}

void node_pskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::parser::validating::complex_content base;
  base::_reset ();

  this->v_state_stack_.clear ();

  this->v_state_attr_stack_.clear ();

  if (this->name_parser_)
    this->name_parser_->_reset ();

  if (this->class__parser_)
    this->class__parser_->_reset ();

  this->resetting_ = true;

  if (this->position_parser_)
    this->position_parser_->_reset ();

  if (this->rotation_parser_)
    this->rotation_parser_->_reset ();

  if (this->scale_parser_)
    this->scale_parser_->_reset ();

  if (this->attribute_parser_)
    this->attribute_parser_->_reset ();

  this->resetting_ = false;
}

#include <assert.h>

// Element validation and dispatch functions for scene_graph_pskel.
//
bool scene_graph_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "nodes" && ns.empty ())
        s = 0UL;
      else if (n == "scenes" && ns.empty ())
        s = 1UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &scene_graph_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool scene_graph_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void scene_graph_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void scene_graph_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void scene_graph_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "nodes" && ns.empty ())
      {
        if (start)
        {
          if (this->nodes_parser_)
          {
            this->nodes_parser_->pre ();
            ctx.nested_parser (this->nodes_parser_);
          }
        }
        else
        {
          if (this->nodes_parser_ != 0)
          {
            ::nodes* tmp = this->nodes_parser_->post_nodes ();
            this->nodes (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "scenes" && ns.empty ())
      {
        if (start)
        {
          if (this->scenes_parser_)
          {
            this->scenes_parser_->pre ();
            ctx.nested_parser (this->scenes_parser_);
          }
        }
        else
        {
          if (this->scenes_parser_ != 0)
          {
            ::scenes* tmp = this->scenes_parser_->post_scenes ();
            this->scenes (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for nodes_pskel.
//
bool nodes_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "node" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &nodes_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool nodes_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void nodes_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void nodes_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void nodes_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "node" && ns.empty ())
      {
        if (start)
        {
          if (this->node_parser_)
          {
            this->node_parser_->pre ();
            ctx.nested_parser (this->node_parser_);
          }
        }
        else
        {
          if (this->node_parser_ != 0)
          {
            ::node* tmp = this->node_parser_->post_node ();
            this->node (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for scenes_pskel.
//
bool scenes_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "scene" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &scenes_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        if (vd->count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return true;
        }

        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool scenes_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void scenes_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void scenes_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_schema_error (::xsde::cxx::schema_error::expected_element);

  this->v_state_stack_.pop ();
}

void scenes_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "scene" && ns.empty ())
      {
        if (start)
        {
          if (this->scene_parser_)
          {
            this->scene_parser_->pre ();
            ctx.nested_parser (this->scene_parser_);
          }
        }
        else
        {
          if (this->scene_parser_ != 0)
          {
            const ::scene& tmp = this->scene_parser_->post_scene ();
            this->scene (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          break;
        }

        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for node_pskel.
//
bool node_pskel::
_start_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (base::_start_element_impl (ns, n))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL && !ctx.error_type ())
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "position" && ns.empty ())
        s = 0UL;
      else if (n == "rotation" && ns.empty ())
        s = 1UL;
      else if (n == "scale" && ns.empty ())
        s = 2UL;
      else if (n == "attribute" && ns.empty ())
        s = 3UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &node_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, true);
      }
      else
      {
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool node_pskel::
_end_element_impl (const ::xsde::cxx::ro_string& ns,
                   const ::xsde::cxx::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    if (!base::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void node_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void node_pskel::
_post_e_validate ()
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xsde::cxx::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, true);

    if (ctx.error_type ())
      return;

    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }


  this->v_state_stack_.pop ();
}

void node_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  XSDE_UNUSED (ctx);

  switch (state)
  {
    case 0UL:
    {
      if (n == "position" && ns.empty ())
      {
        if (start)
        {
          if (this->position_parser_)
          {
            this->position_parser_->pre ();
            ctx.nested_parser (this->position_parser_);
          }
        }
        else
        {
          if (this->position_parser_ != 0)
          {
            const ::vec3_type& tmp = this->position_parser_->post_vec3_type ();
            this->position (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "rotation" && ns.empty ())
      {
        if (start)
        {
          if (this->rotation_parser_)
          {
            this->rotation_parser_->pre ();
            ctx.nested_parser (this->rotation_parser_);
          }
        }
        else
        {
          if (this->rotation_parser_ != 0)
          {
            const ::vec4_type& tmp = this->rotation_parser_->post_vec4_type ();
            this->rotation (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "scale" && ns.empty ())
      {
        if (start)
        {
          if (this->scale_parser_)
          {
            this->scale_parser_->pre ();
            ctx.nested_parser (this->scale_parser_);
          }
        }
        else
        {
          if (this->scale_parser_ != 0)
          {
            const ::vec3_type& tmp = this->scale_parser_->post_vec3_type ();
            this->scale (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "attribute" && ns.empty ())
      {
        if (start)
        {
          if (this->attribute_parser_)
          {
            this->attribute_parser_->pre ();
            ctx.nested_parser (this->attribute_parser_);
          }
        }
        else
        {
          if (this->attribute_parser_ != 0)
          {
            const ::attribute& tmp = this->attribute_parser_->post_attribute ();
            this->attribute (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Attribute validation and dispatch functions for vec3_type_pskel.
//
bool vec3_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "x" && ns.empty ())
  {
    if (this->x_parser_)
    {
      this->x_parser_->pre ();

      this->x_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->x_parser_->_characters (s);

      if (!ctx.error_type ())
        this->x_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->x_parser_->post_float ();

        this->x (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->x = true;
    return true;
  }

  if (n == "y" && ns.empty ())
  {
    if (this->y_parser_)
    {
      this->y_parser_->pre ();

      this->y_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->y_parser_->_characters (s);

      if (!ctx.error_type ())
        this->y_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->y_parser_->post_float ();

        this->y (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->y = true;
    return true;
  }

  if (n == "z" && ns.empty ())
  {
    if (this->z_parser_)
    {
      this->z_parser_->pre ();

      this->z_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->z_parser_->_characters (s);

      if (!ctx.error_type ())
        this->z_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->z_parser_->post_float ();

        this->z (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->z = true;
    return true;
  }

  return false;
}

void vec3_type_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.x = false;
  as.y = false;
  as.z = false;
}

void vec3_type_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.x)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.y)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.z)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for vec4_type_pskel.
//
bool vec4_type_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "x" && ns.empty ())
  {
    if (this->x_parser_)
    {
      this->x_parser_->pre ();

      this->x_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->x_parser_->_characters (s);

      if (!ctx.error_type ())
        this->x_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->x_parser_->post_float ();

        this->x (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->x = true;
    return true;
  }

  if (n == "y" && ns.empty ())
  {
    if (this->y_parser_)
    {
      this->y_parser_->pre ();

      this->y_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->y_parser_->_characters (s);

      if (!ctx.error_type ())
        this->y_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->y_parser_->post_float ();

        this->y (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->y = true;
    return true;
  }

  if (n == "z" && ns.empty ())
  {
    if (this->z_parser_)
    {
      this->z_parser_->pre ();

      this->z_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->z_parser_->_characters (s);

      if (!ctx.error_type ())
        this->z_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->z_parser_->post_float ();

        this->z (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->z = true;
    return true;
  }

  if (n == "w" && ns.empty ())
  {
    if (this->w_parser_)
    {
      this->w_parser_->pre ();

      this->w_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->w_parser_->_characters (s);

      if (!ctx.error_type ())
        this->w_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        float tmp = this->w_parser_->post_float ();

        this->w (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->w = true;
    return true;
  }

  return false;
}

void vec4_type_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.x = false;
  as.y = false;
  as.z = false;
  as.w = false;
}

void vec4_type_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.x)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.y)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.z)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.w)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for scene_pskel.
//
bool scene_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_token ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  if (n == "graph" && ns.empty ())
  {
    if (this->graph_parser_)
    {
      this->graph_parser_->pre ();

      this->graph_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->graph_parser_->_characters (s);

      if (!ctx.error_type ())
        this->graph_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->graph_parser_->post_string ();

        this->graph (tmp);
      }
    }

    return true;
  }

  return false;
}

void scene_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.name = false;
}

void scene_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Attribute validation and dispatch functions for attribute_pskel.
//
bool attribute_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_token ();

        this->name (tmp);
      }
    }

    return true;
  }

  if (n == "value" && ns.empty ())
  {
    if (this->value_parser_)
    {
      this->value_parser_->pre ();

      this->value_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->value_parser_->_characters (s);

      if (!ctx.error_type ())
        this->value_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->value_parser_->post_string ();

        this->value (tmp);
      }
    }

    return true;
  }

  return false;
}

// Attribute validation and dispatch functions for node_pskel.
//
bool node_pskel::
_attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                           const ::xsde::cxx::ro_string& n,
                           const ::xsde::cxx::ro_string& s)
{
  ::xsde::cxx::parser::context& ctx = this->_context ();

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
    {
      this->name_parser_->pre ();

      this->name_parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->name_parser_->_characters (s);

      if (!ctx.error_type ())
        this->name_parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->name_parser_->post_token ();

        this->name (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
    return true;
  }

  if (n == "class" && ns.empty ())
  {
    if (this->class__parser_)
    {
      this->class__parser_->pre ();

      this->class__parser_->_pre_impl (ctx);

      if (!ctx.error_type ())
        this->class__parser_->_characters (s);

      if (!ctx.error_type ())
        this->class__parser_->_post_impl ();

      if (!ctx.error_type ())
      {
        const ::std::string& tmp = this->class__parser_->post_token ();

        this->class_ (tmp);
      }
    }

    static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->class_ = true;
    return true;
  }

  return false;
}

void node_pskel::
_pre_a_validate ()
{
  this->v_state_attr_stack_.push ();
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  as.name = false;
  as.class_ = false;
}

void node_pskel::
_post_a_validate ()
{
  v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

  if (!as.name)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }

  if (!as.class_)
  {
    this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
    return;
  }


  this->v_state_attr_stack_.pop ();
}

// Begin epilogue.
//
//
// End epilogue.

