// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "scene.hxx"

// vec3_type
//

float vec3_type::
x () const
{
  return this->x_;
}

float& vec3_type::
x ()
{
  return this->x_;
}

void vec3_type::
x (float x)
{
  this->x_ = x;
}

float vec3_type::
y () const
{
  return this->y_;
}

float& vec3_type::
y ()
{
  return this->y_;
}

void vec3_type::
y (float x)
{
  this->y_ = x;
}

float vec3_type::
z () const
{
  return this->z_;
}

float& vec3_type::
z ()
{
  return this->z_;
}

void vec3_type::
z (float x)
{
  this->z_ = x;
}

// vec4_type
//

float vec4_type::
x () const
{
  return this->x_;
}

float& vec4_type::
x ()
{
  return this->x_;
}

void vec4_type::
x (float x)
{
  this->x_ = x;
}

float vec4_type::
y () const
{
  return this->y_;
}

float& vec4_type::
y ()
{
  return this->y_;
}

void vec4_type::
y (float x)
{
  this->y_ = x;
}

float vec4_type::
z () const
{
  return this->z_;
}

float& vec4_type::
z ()
{
  return this->z_;
}

void vec4_type::
z (float x)
{
  this->z_ = x;
}

float vec4_type::
w () const
{
  return this->w_;
}

float& vec4_type::
w ()
{
  return this->w_;
}

void vec4_type::
w (float x)
{
  this->w_ = x;
}

// scene-graph
//

bool scene_graph::
nodes_present () const
{
  return this->nodes_ != 0;
}

const ::nodes& scene_graph::
nodes () const
{
  return *this->nodes_;
}

::nodes& scene_graph::
nodes ()
{
  return *this->nodes_;
}

void scene_graph::
nodes (::nodes* x)
{
  delete this->nodes_;
  this->nodes_ = x;
}

bool scene_graph::
scenes_present () const
{
  return this->scenes_ != 0;
}

const ::scenes& scene_graph::
scenes () const
{
  return *this->scenes_;
}

::scenes& scene_graph::
scenes ()
{
  return *this->scenes_;
}

void scene_graph::
scenes (::scenes* x)
{
  delete this->scenes_;
  this->scenes_ = x;
}

// nodes
//

const nodes::node_sequence& nodes::
node () const
{
  return this->node_;
}

nodes::node_sequence& nodes::
node ()
{
  return this->node_;
}

// scene
//

const ::std::string& scene::
name () const
{
  return this->name_;
}

::std::string& scene::
name ()
{
  return this->name_;
}

void scene::
name (const ::std::string& x)
{
  this->name_ = x;
}

bool scene::
graph_present () const
{
  return this->graph_present_;
}

void scene::
graph_present (bool x)
{
  this->graph_present_ = x;
}

const ::std::string& scene::
graph () const
{
  return this->graph_;
}

::std::string& scene::
graph ()
{
  return this->graph_;
}

void scene::
graph (const ::std::string& x)
{
  this->graph_ = x;
  this->graph_present_ = true;
}

// scenes
//

const scenes::scene_sequence& scenes::
scene () const
{
  return this->scene_;
}

scenes::scene_sequence& scenes::
scene ()
{
  return this->scene_;
}

// attribute
//

bool attribute::
name_present () const
{
  return this->name_present_;
}

void attribute::
name_present (bool x)
{
  this->name_present_ = x;
}

const ::std::string& attribute::
name () const
{
  return this->name_;
}

::std::string& attribute::
name ()
{
  return this->name_;
}

void attribute::
name (const ::std::string& x)
{
  this->name_ = x;
  this->name_present_ = true;
}

bool attribute::
value_present () const
{
  return this->value_present_;
}

void attribute::
value_present (bool x)
{
  this->value_present_ = x;
}

const ::std::string& attribute::
value () const
{
  return this->value_;
}

::std::string& attribute::
value ()
{
  return this->value_;
}

void attribute::
value (const ::std::string& x)
{
  this->value_ = x;
  this->value_present_ = true;
}

// node
//

const ::std::string& node::
name () const
{
  return this->name_;
}

::std::string& node::
name ()
{
  return this->name_;
}

void node::
name (const ::std::string& x)
{
  this->name_ = x;
}

const ::std::string& node::
class_ () const
{
  return this->class__;
}

::std::string& node::
class_ ()
{
  return this->class__;
}

void node::
class_ (const ::std::string& x)
{
  this->class__ = x;
}

bool node::
position_present () const
{
  return this->position_present_;
}

void node::
position_present (bool x)
{
  this->position_present_ = x;
}

const ::vec3_type& node::
position () const
{
  return this->position_;
}

::vec3_type& node::
position ()
{
  return this->position_;
}

void node::
position (const ::vec3_type& x)
{
  this->position_ = x;
  this->position_present_ = true;
}

bool node::
rotation_present () const
{
  return this->rotation_present_;
}

void node::
rotation_present (bool x)
{
  this->rotation_present_ = x;
}

const ::vec4_type& node::
rotation () const
{
  return this->rotation_;
}

::vec4_type& node::
rotation ()
{
  return this->rotation_;
}

void node::
rotation (const ::vec4_type& x)
{
  this->rotation_ = x;
  this->rotation_present_ = true;
}

bool node::
scale_present () const
{
  return this->scale_present_;
}

void node::
scale_present (bool x)
{
  this->scale_present_ = x;
}

const ::vec3_type& node::
scale () const
{
  return this->scale_;
}

::vec3_type& node::
scale ()
{
  return this->scale_;
}

void node::
scale (const ::vec3_type& x)
{
  this->scale_ = x;
  this->scale_present_ = true;
}

const node::attribute_sequence& node::
attribute () const
{
  return this->attribute_;
}

node::attribute_sequence& node::
attribute ()
{
  return this->attribute_;
}

#include <stdlib.h>
#include <new>

// vec3_type
//

vec3_type::
vec3_type ()
{
}

vec3_type::
~vec3_type ()
{
}

vec3_type::
vec3_type (const vec3_type& x)
{
  XSDE_UNUSED (x);
  this->x_ = x.x_;
  this->y_ = x.y_;
  this->z_ = x.z_;
}

vec3_type& vec3_type::
operator= (const vec3_type& x)
{
  XSDE_UNUSED (x);
  this->x_ = x.x_;
  this->y_ = x.y_;
  this->z_ = x.z_;
  return *this;
}

// vec4_type
//

vec4_type::
vec4_type ()
{
}

vec4_type::
~vec4_type ()
{
}

vec4_type::
vec4_type (const vec4_type& x)
{
  XSDE_UNUSED (x);
  this->x_ = x.x_;
  this->y_ = x.y_;
  this->z_ = x.z_;
  this->w_ = x.w_;
}

vec4_type& vec4_type::
operator= (const vec4_type& x)
{
  XSDE_UNUSED (x);
  this->x_ = x.x_;
  this->y_ = x.y_;
  this->z_ = x.z_;
  this->w_ = x.w_;
  return *this;
}

// scene-graph
//

scene_graph::
scene_graph ()
{
  this->nodes_ = 0;
  this->scenes_ = 0;
}

scene_graph::
~scene_graph ()
{
  delete this->nodes_;
  delete this->scenes_;
}

// nodes
//

nodes::
nodes ()
{
}

nodes::
~nodes ()
{
}

// scene
//

scene::
scene ()
{
  this->graph_present_ = false;
}

scene::
~scene ()
{
}

scene::
scene (const scene& x)
{
  XSDE_UNUSED (x);
  this->name_ = x.name_;
  this->graph_present_ = x.graph_present_;
  if (this->graph_present_)
    this->graph_ = x.graph_;
}

scene& scene::
operator= (const scene& x)
{
  XSDE_UNUSED (x);
  this->name_ = x.name_;
  this->graph_present_ = x.graph_present_;
  if (this->graph_present_)
    this->graph_ = x.graph_;
  return *this;
}

// scenes
//

scenes::
scenes ()
{
}

scenes::
~scenes ()
{
}

// attribute
//

attribute::
attribute ()
{
  this->name_present_ = false;
  this->value_present_ = false;
}

attribute::
~attribute ()
{
}

attribute::
attribute (const attribute& x)
{
  XSDE_UNUSED (x);
  this->name_present_ = x.name_present_;
  if (this->name_present_)
    this->name_ = x.name_;
  this->value_present_ = x.value_present_;
  if (this->value_present_)
    this->value_ = x.value_;
}

attribute& attribute::
operator= (const attribute& x)
{
  XSDE_UNUSED (x);
  this->name_present_ = x.name_present_;
  if (this->name_present_)
    this->name_ = x.name_;
  this->value_present_ = x.value_present_;
  if (this->value_present_)
    this->value_ = x.value_;
  return *this;
}

// node
//

node::
node ()
{
  this->position_present_ = false;
  this->rotation_present_ = false;
  this->scale_present_ = false;
}

node::
~node ()
{
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

