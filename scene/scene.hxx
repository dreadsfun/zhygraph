// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

#ifndef E__VS14PRJBKP_ENGINE_SCENE_SCENE_HXX
#define E__VS14PRJBKP_ENGINE_SCENE_SCENE_HXX

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include <string>
#include <xsde/cxx/hybrid/xml-schema.hxx>
#include <xsde/cxx/hybrid/sequence.hxx>

namespace xml_schema
{
  using ::xsde::cxx::hybrid::any_type;
  typedef ::std::string any_simple_type;

  typedef signed char byte;
  using ::xsde::cxx::hybrid::byte_base;

  typedef unsigned char unsigned_byte;
  using ::xsde::cxx::hybrid::unsigned_byte_base;

  typedef short short_;
  using ::xsde::cxx::hybrid::short_base;

  typedef unsigned short unsigned_short;
  using ::xsde::cxx::hybrid::unsigned_short_base;

  typedef int int_;
  using ::xsde::cxx::hybrid::int_base;

  typedef unsigned int unsigned_int;
  using ::xsde::cxx::hybrid::unsigned_int_base;

  typedef long long long_;
  using ::xsde::cxx::hybrid::long_base;

  typedef unsigned long long unsigned_long;
  using ::xsde::cxx::hybrid::unsigned_long_base;

  typedef long integer;
  using ::xsde::cxx::hybrid::integer_base;

  typedef long non_positive_integer;
  using ::xsde::cxx::hybrid::non_positive_integer_base;

  typedef unsigned long non_negative_integer;
  using ::xsde::cxx::hybrid::non_negative_integer_base;

  typedef unsigned long positive_integer;
  using ::xsde::cxx::hybrid::positive_integer_base;

  typedef long negative_integer;
  using ::xsde::cxx::hybrid::negative_integer_base;

  typedef bool boolean;
  using ::xsde::cxx::hybrid::boolean_base;

  typedef float float_;
  using ::xsde::cxx::hybrid::float_base;

  typedef double double_;
  using ::xsde::cxx::hybrid::double_base;

  typedef double decimal;
  using ::xsde::cxx::hybrid::decimal_base;

  typedef ::std::string string;

  typedef ::std::string normalized_string;

  typedef ::std::string token;

  typedef ::std::string name;

  typedef ::std::string nmtoken;

  typedef ::xsde::cxx::string_sequence nmtokens;

  typedef ::std::string ncname;

  typedef ::std::string language;

  typedef ::std::string id;

  typedef ::std::string idref;

  typedef ::xsde::cxx::string_sequence idrefs;

  typedef ::std::string uri;

  using ::xsde::cxx::qname;

  using ::xsde::cxx::buffer;
  typedef ::xsde::cxx::buffer base64_binary;
  typedef ::xsde::cxx::buffer hex_binary;

  using ::xsde::cxx::time_zone;
  using ::xsde::cxx::date;
  using ::xsde::cxx::date_time;
  using ::xsde::cxx::duration;
  using ::xsde::cxx::gday;
  using ::xsde::cxx::gmonth;
  using ::xsde::cxx::gmonth_day;
  using ::xsde::cxx::gyear;
  using ::xsde::cxx::gyear_month;
  using ::xsde::cxx::time;

  using ::xsde::cxx::hybrid::pod_sequence;
  using ::xsde::cxx::hybrid::fix_sequence;
  using ::xsde::cxx::hybrid::var_sequence;
  using ::xsde::cxx::string_sequence;
  using ::xsde::cxx::hybrid::data_sequence;
}

class vec3_type;
class vec4_type;
class scene_graph;
class nodes;
class scene;
class scenes;
class attribute;
class node;

// vec3_type (fixed-length)
//
class vec3_type
{
  public:
  vec3_type ();

  vec3_type (const vec3_type&);
  vec3_type& operator= (const vec3_type&);

  ~vec3_type ();

  // x
  //
  float
  x () const;

  float&
  x ();

  void
  x (float);

  // y
  //
  float
  y () const;

  float&
  y ();

  void
  y (float);

  // z
  //
  float
  z () const;

  float&
  z ();

  void
  z (float);

  private:
  float x_;
  float y_;
  float z_;
};

// vec4_type (fixed-length)
//
class vec4_type
{
  public:
  vec4_type ();

  vec4_type (const vec4_type&);
  vec4_type& operator= (const vec4_type&);

  ~vec4_type ();

  // x
  //
  float
  x () const;

  float&
  x ();

  void
  x (float);

  // y
  //
  float
  y () const;

  float&
  y ();

  void
  y (float);

  // z
  //
  float
  z () const;

  float&
  z ();

  void
  z (float);

  // w
  //
  float
  w () const;

  float&
  w ();

  void
  w (float);

  private:
  float x_;
  float y_;
  float z_;
  float w_;
};

// scene-graph (variable-length)
//
class scene_graph
{
  private:
  scene_graph (const scene_graph&);
  scene_graph& operator= (const scene_graph&);

  public:
  scene_graph ();

  ~scene_graph ();

  // nodes
  //
  bool
  nodes_present () const;

  const ::nodes&
  nodes () const;

  ::nodes&
  nodes ();

  void
  nodes (::nodes*);

  // scenes
  //
  bool
  scenes_present () const;

  const ::scenes&
  scenes () const;

  ::scenes&
  scenes ();

  void
  scenes (::scenes*);

  private:
  ::nodes* nodes_;
  ::scenes* scenes_;
};

// nodes (variable-length)
//
class nodes
{
  private:
  nodes (const nodes&);
  nodes& operator= (const nodes&);

  public:
  nodes ();

  ~nodes ();

  // node
  //
  typedef ::xsde::cxx::hybrid::var_sequence< ::node > node_sequence;
  typedef node_sequence::iterator node_iterator;
  typedef node_sequence::const_iterator node_const_iterator;

  const node_sequence&
  node () const;

  node_sequence&
  node ();

  private:
  node_sequence node_;
};

// scene (fixed-length)
//
class scene
{
  public:
  scene ();

  scene (const scene&);
  scene& operator= (const scene&);

  ~scene ();

  // name
  //
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // graph
  //
  bool
  graph_present () const;

  void
  graph_present (bool);

  const ::std::string&
  graph () const;

  ::std::string&
  graph ();

  void
  graph (const ::std::string&);

  private:
  ::std::string name_;
  ::std::string graph_;
  unsigned char graph_present_;
};

// scenes (variable-length)
//
class scenes
{
  private:
  scenes (const scenes&);
  scenes& operator= (const scenes&);

  public:
  scenes ();

  ~scenes ();

  // scene
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::scene > scene_sequence;
  typedef scene_sequence::iterator scene_iterator;
  typedef scene_sequence::const_iterator scene_const_iterator;

  const scene_sequence&
  scene () const;

  scene_sequence&
  scene ();

  private:
  scene_sequence scene_;
};

// attribute (fixed-length)
//
class attribute
{
  public:
  attribute ();

  attribute (const attribute&);
  attribute& operator= (const attribute&);

  ~attribute ();

  // name
  //
  bool
  name_present () const;

  void
  name_present (bool);

  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // value
  //
  bool
  value_present () const;

  void
  value_present (bool);

  const ::std::string&
  value () const;

  ::std::string&
  value ();

  void
  value (const ::std::string&);

  private:
  ::std::string name_;
  unsigned char name_present_;
  ::std::string value_;
  unsigned char value_present_;
};

// node (variable-length)
//
class node
{
  private:
  node (const node&);
  node& operator= (const node&);

  public:
  node ();

  ~node ();

  // name
  //
  const ::std::string&
  name () const;

  ::std::string&
  name ();

  void
  name (const ::std::string&);

  // class
  //
  const ::std::string&
  class_ () const;

  ::std::string&
  class_ ();

  void
  class_ (const ::std::string&);

  // position
  //
  bool
  position_present () const;

  void
  position_present (bool);

  const ::vec3_type&
  position () const;

  ::vec3_type&
  position ();

  void
  position (const ::vec3_type&);

  // rotation
  //
  bool
  rotation_present () const;

  void
  rotation_present (bool);

  const ::vec4_type&
  rotation () const;

  ::vec4_type&
  rotation ();

  void
  rotation (const ::vec4_type&);

  // scale
  //
  bool
  scale_present () const;

  void
  scale_present (bool);

  const ::vec3_type&
  scale () const;

  ::vec3_type&
  scale ();

  void
  scale (const ::vec3_type&);

  // attribute
  //
  typedef ::xsde::cxx::hybrid::fix_sequence< ::attribute > attribute_sequence;
  typedef attribute_sequence::iterator attribute_iterator;
  typedef attribute_sequence::const_iterator attribute_const_iterator;

  const attribute_sequence&
  attribute () const;

  attribute_sequence&
  attribute ();

  private:
  ::std::string name_;
  ::std::string class__;
  ::vec3_type position_;
  unsigned char position_present_;
  ::vec4_type rotation_;
  unsigned char rotation_present_;
  ::vec3_type scale_;
  unsigned char scale_present_;
  attribute_sequence attribute_;
};

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // E__VS14PRJBKP_ENGINE_SCENE_SCENE_HXX
